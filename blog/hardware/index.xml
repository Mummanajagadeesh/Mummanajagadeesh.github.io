<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hardware on Jagadeesh Mummana | Portfolio</title><link>https://mummanajagadeesh.github.io/blog/hardware/</link><description>Recent content in Hardware on Jagadeesh Mummana | Portfolio</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 15 May 2025 05:30:00 +0000</lastBuildDate><atom:link href="https://mummanajagadeesh.github.io/blog/hardware/index.xml" rel="self" type="application/rss+xml"/><item><title>Why RISC-V Can Be a Game Changer?</title><link>https://mummanajagadeesh.github.io/blog/why-riscv-is-better/</link><pubDate>Thu, 15 May 2025 05:30:00 +0000</pubDate><guid>https://mummanajagadeesh.github.io/blog/why-riscv-is-better/</guid><description>&lt;p>In a world dominated by proprietary chip architectures, a quiet shift is underway. RISC-V, an open-source alternative, is redefining how we think about processor design—especially in the VLSI world—by enabling greater customization, transparency, and control at the hardware level.&lt;/p></description></item><item><title>Introduction to VLSI Design Flow: RTL to GDSII</title><link>https://mummanajagadeesh.github.io/blog/vlsi-design-flow/</link><pubDate>Thu, 08 May 2025 05:30:00 +0000</pubDate><guid>https://mummanajagadeesh.github.io/blog/vlsi-design-flow/</guid><description>&lt;p>Wonder why AI, modern smartphones, and countless digital devices have become so powerful yet compact? The secret lies in the ability to pack billions of transistors into tiny silicon chips — a feat accomplished through &lt;strong>Very Large-Scale Integration (VLSI)&lt;/strong>. At the core of this accomplishment is a complex, multi-step design flow that transforms abstract hardware concepts into a physical chip ready for fabrication.&lt;/p></description></item><item><title>I²C: Fundamentals and Practical Aspects of Inter-Integrated Circuit Communication</title><link>https://mummanajagadeesh.github.io/blog/i2c/</link><pubDate>Tue, 08 Apr 2025 05:30:00 +0000</pubDate><guid>https://mummanajagadeesh.github.io/blog/i2c/</guid><description>&lt;p>I²C is a &lt;strong>synchronous, half-duplex, multi-master, multi-slave&lt;/strong> serial communication protocol developed by Philips (now NXP) in the 1980s. It was designed for &lt;strong>on-board communication between integrated circuits&lt;/strong>, especially in systems with multiple low-speed peripherals controlled by a microcontroller.&lt;/p></description></item><item><title>SPI: Understanding the Serial Peripheral Interface Protocol</title><link>https://mummanajagadeesh.github.io/blog/spi/</link><pubDate>Tue, 01 Apr 2025 05:30:00 +0000</pubDate><guid>https://mummanajagadeesh.github.io/blog/spi/</guid><description>&lt;p>SPI is a &lt;strong>synchronous&lt;/strong> serial communication protocol designed for &lt;strong>high-speed, full-duplex data exchange&lt;/strong> between a master device and one or more peripheral (slave) devices. It was originally developed by Motorola and remains widely adopted in microcontrollers, sensors, memory chips, ADCs/DACs, displays, and more.&lt;/p></description></item><item><title>UART: A Detailed Overview of Asynchronous Serial Communication</title><link>https://mummanajagadeesh.github.io/blog/uart/</link><pubDate>Thu, 27 Mar 2025 05:30:00 +0000</pubDate><guid>https://mummanajagadeesh.github.io/blog/uart/</guid><description>&lt;p>UART is one of the oldest and most fundamental methods of serial communication in embedded systems. As its name suggests, it operates asynchronously, meaning &lt;strong>there is no shared clock signal&lt;/strong> between the transmitter and the receiver. This makes UART especially attractive in scenarios where simplicity and minimal wiring are important.&lt;/p></description></item><item><title>Demystifying UART, SPI, and I2C: Communication Between Chips</title><link>https://mummanajagadeesh.github.io/blog/communication-between-chips/</link><pubDate>Mon, 24 Mar 2025 05:30:00 +0000</pubDate><guid>https://mummanajagadeesh.github.io/blog/communication-between-chips/</guid><description>&lt;p>In both VLSI design and embedded systems, no chip operates in isolation. Whether it&amp;rsquo;s a microcontroller interfacing with sensors, a processor communicating with memory modules, or multiple peripherals synchronizing data, &lt;strong>inter-chip communication&lt;/strong> is fundamental to building reliable and scalable hardware systems.&lt;/p></description></item><item><title>Setting Up Icarus Verilog on Google Colab</title><link>https://mummanajagadeesh.github.io/blog/setting-up-icarus-verilog-on-google-colab/</link><pubDate>Wed, 19 Feb 2025 05:30:00 +0000</pubDate><guid>https://mummanajagadeesh.github.io/blog/setting-up-icarus-verilog-on-google-colab/</guid><description>&lt;p>Google Colab is a cloud-based platform that allows you to run code in a Jupyter Notebook environment. While it&amp;rsquo;s primarily designed for Python, it can also be adapted to run Verilog simulations using Icarus Verilog. This guide walks you through setting up Icarus Verilog on Colab, writing and compiling Verilog code, running simulations, and generating waveform files for debugging—all in the cloud.&lt;/p></description></item></channel></rss>