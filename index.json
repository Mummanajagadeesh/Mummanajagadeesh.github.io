[{"blog":["tips","hugo","site","blog","s"],"contents":"Hugo is a fast, flexible, and open-source static site generator that allows you to build websites with ease. Originally popular for blogging, Hugo’s versatility makes it ideal for creating a wide range of sites — from personal portfolios and academic project showcases to documentation hubs and even e-commerce sites. Whether you’re building a professional portfolio, a research site to share your academic work, or a personal blog, Hugo has you covered.\nThis guide will take you through the entire process of building a website using Hugo, from installation to deployment, with practical tips to make your site look professional and unique.\n1. Install Hugo macOS (using Homebrew) If you\u0026rsquo;re on macOS and have Homebrew installed, this is the easiest way to install Hugo:\nbrew install hugo Windows (using Chocolatey) For Windows, use the Chocolatey package manager:\nchoco install hugo -confirm Linux (Debian/Ubuntu) If you\u0026rsquo;re on Linux, use the following commands to install Hugo:\nsudo apt-get update sudo apt-get install hugo Alternatively, you can download a precompiled binary for your platform from the Hugo releases page and extract it manually.\nVerifying Installation Once installed, verify the installation by running:\nhugo version This will show the version of Hugo you have installed, confirming that it is ready to go.\n2. Create a New Hugo Site After Hugo is installed, you can create a new site with a simple command. Open a terminal (or command prompt on Windows) and run the following:\nhugo new site \u0026lt;your-site-name\u0026gt; This creates a new directory (\u0026lt;your-site-name\u0026gt;) with the basic structure of a Hugo site. You’ll see directories like content/, layouts/, and themes/.\n3. Choose and Install a Theme Hugo uses themes to determine how your website looks. To browse available themes, head to the Hugo Themes website. There are hundreds of free and open-source themes to choose from.\nOnce you\u0026rsquo;ve chosen a theme, you can add it to your site by following these steps:\nUsing Git Submodule (Recommended) Inside your Hugo site directory, initialize a Git repository (if it isn’t already initialized):\ngit init Add the theme as a submodule:\ngit submodule add \u0026lt;theme-repository-url\u0026gt; themes/\u0026lt;theme-name\u0026gt; git submodule update --init --recursive Configure your site to use the new theme. Open config.toml (or config.yaml or config.json, depending on your configuration format) and set the theme:\ntheme = \u0026#34;\u0026lt;theme-name\u0026gt;\u0026#34; Alternatively, you can download the theme manually, but using Git submodules is more efficient for managing updates.\n4. Understanding Hugo’s Directory Structure Hugo uses a specific directory structure to organize your website’s content, assets, and configuration. Here\u0026rsquo;s a breakdown of the most important directories and files:\ncontent/: Where your content lives. This is where you will add markdown files for posts, pages, and other content types. themes/: Contains the themes you use in your site. Each theme will have a layouts/ directory, which contains the theme’s templates. static/: This directory holds static assets like images, CSS, JavaScript files, etc. Files here are copied directly to the root of the public/ directory when Hugo generates the site. layouts/: This folder is used for your custom templates. You can override theme templates or create your own templates for specific types of content. config.toml (or config.yaml, config.json): This is your site’s configuration file, where you set global parameters like the site’s title, base URL, language, theme, and more. 5. Create and Organize Content Now it’s time to add content to your website. You can create content types like blog posts, pages, or custom content.\nCreating a New Page or Post To create a new page or post, run the following command:\nhugo new \u0026lt;content-type\u0026gt;/\u0026lt;page-name\u0026gt;.md For example, to create a blog post:\nhugo new posts/my-first-post.md This will create a markdown file in content/posts/my-first-post.md.\nMarkdown Syntax for Content In the generated .md file, you\u0026rsquo;ll see frontmatter and markdown content:\n--- title: \u0026#34;My First Post\u0026#34; date: 2025-04-02 draft: true --- # Welcome to my blog! This is a simple markdown file to demonstrate Hugo. The frontmatter (between the --- lines) contains metadata for your content. You can set fields like title, date, draft, and custom parameters like tags or author. The content section uses standard markdown syntax. You can write paragraphs, lists, headings, links, images, and much more. Publishing Content Once you’re ready to publish, you can set draft: false in the frontmatter and run hugo server to preview the site.\n6. Start the Development Server To see your site in action, you can run a local development server:\nhugo server By default, this will run a server on http://localhost:1313. As you modify content or templates, Hugo will automatically regenerate the site and refresh the page.\n7. Building the Site for Production When you\u0026rsquo;re satisfied with your site, you can build it for production. Run the following command:\nhugo This will generate the static website in the public/ directory. The public/ directory will contain all the HTML files, assets, and other content required to host your site.\n8. Deploying the Site Once your site is built, you can deploy it to a variety of hosting platforms. Hugo sites are static, so they can be deployed on platforms like:\nGitHub Pages: You can push the contents of the public/ directory to a GitHub repository and serve it using GitHub Pages. Netlify: A popular static site hosting platform. Just link your GitHub repository to Netlify, and it will automatically build and deploy your site. Vercel: Another static site hosting platform similar to Netlify. Your Own Server: If you have a hosting provider or VPS, you can upload the files in the public/ directory to your web server. Each hosting platform will have specific instructions for deploying Hugo sites, but most of them integrate easily with Git-based workflows.\n9. Customizing Your Site Creating Custom Layouts To modify the look and feel of your site, you can create custom templates in the layouts/ directory. You can override default templates from the theme by placing your custom templates here.\nFor example, to modify the homepage layout, you can create layouts/index.html or layouts/_default/baseof.html to adjust the base layout structure.\nAdding Shortcodes Hugo supports shortcodes, which are snippets of reusable content. You can use shortcodes to easily insert dynamic elements like galleries, videos, or calls to action. Here’s an example of using a shortcode to embed a YouTube video:\nShortcodes can be defined in the layouts/shortcodes/ directory.\n10. Additional Tips Taxonomies: You can organize content using taxonomies like categories or tags. Add this configuration in config.toml:\n[taxonomies] category = \u0026#34;categories\u0026#34; tag = \u0026#34;tags\u0026#34; Multilingual Sites: Hugo supports multilingual sites. You can define different content for different languages in the content/ folder, such as content/en/ and content/es/.\nHugo Modules: Hugo also supports modules, which allow you to manage external dependencies in your site, such as themes or libraries.\nGitHub Actions: You can automate your Hugo build and deployment process using GitHub Actions for continuous deployment.\nConclusion Hugo is a powerful tool for building fast, static websites. With this guide, you should now be able to create, customize, and deploy your own Hugo-powered site. Whether you\u0026rsquo;re building a blog, portfolio, or documentation site, Hugo\u0026rsquo;s flexibility and speed make it a fantastic choice for modern static websites.\nHappy building!\nQuick Note: The site you’re reading this from is also built using Hugo — but with a ton of tweaks to make it uniquely mine! I started with the Geeky-Hugo theme as the base and added a bunch of customizations, including:\nCustom Layouts: Modified to fit my style and content structure.\nShortcodes: Added some handy ones for embedding interactive elements.\nCustom CSS: To give it a personal touch and make it look just right.\nLaTeX Support: For displaying complex mathematical equations seamlessly.\nExtended Pages: Not just limited to blogs — I’ve got project showcases, technical documentation, and more.\nIt’s proof that Hugo isn’t just about simple blogs — with some effort, you can turn it into a full-fledged portfolio or academic site!\n","date":"March 1, 2025","image":"/images/post/hugo/image_hu175449011401174589.png","permalink":"/blog/getting-started-with-hugo/","title":"Getting Started with Hugo: A Step-by-Step Guide"},{"blog":["tips","verilog","blog","s"],"contents":"Google Colab is a cloud-based platform that allows you to run code in a Jupyter Notebook environment. While it\u0026rsquo;s primarily designed for Python, it can also be adapted to run Verilog simulations using Icarus Verilog. This guide walks you through setting up Icarus Verilog on Colab, writing and compiling Verilog code, running simulations, and generating waveform files for debugging—all in the cloud.\nYou might wonder why we’d even consider simulating Verilog code on Colab when there are many industry-grade tools available that offer synthesis, timing analysis, and complete hardware design capabilities. The answer lies in accessibility. Icarus Verilog is an open-source, lightweight alternative that remains incredibly relevant—especially for students, educators, and hobbyists. It’s perfect for academic projects, quick prototyping, and learning digital design fundamentals without the overhead of licensed tools or heavy installations.\nOne major advantage of using Colab is its seamless integration with the web—allowing you to import datasets or files directly from URLs or cloud storage. This becomes particularly useful for projects where Verilog testbenches need structured data, such as input vectors, weights, or test cases. With Python handling the preprocessing and formatting, you can easily generate files that your Verilog code can read, enabling a smooth and flexible software-hardware co-design workflow.\nMy own journey into this setup began with a somewhat unconventional idea: training a neural network in Verilog. It was a fun and technically challenging experiment that led me to build this workflow on Colab. If you\u0026rsquo;re curious to see how that turned out, feel free to check out my project here.\nWhy Use Icarus Verilog on Google Colab? Icarus Verilog is an open-source Verilog simulation and synthesis tool that supports a wide range of Verilog constructs. Running it on Google Colab offers several advantages:\nNo need to install software on your local machine. Easy collaboration and sharing through Colab notebooks. Accessible from any device with an internet connection. Free computational resources provided by Google. Now, let\u0026rsquo;s get started with setting up Icarus Verilog on Google Colab.\nInstalling Icarus Verilog Before you can run Verilog simulations, you need to install Icarus Verilog on your Colab environment. To do this, execute the following commands:\n!sudo apt-get update !sudo apt-get install -y iverilog Once installed, verify the installation by checking the version:\n!iverilog -v If the installation is successful, you will see the version information displayed in the output.\nWriting and Running a Simple Verilog Program To test if Icarus Verilog is working correctly, let\u0026rsquo;s write a simple Verilog program that prints a message. In Colab, you can use the %%writefile magic command to create and save Verilog files:\n%%writefile test.v module hello; initial begin $display(\u0026#34;Hello, Icarus Verilog on Colab!\u0026#34;); $finish; end endmodule Compiling and Running the Verilog Code Once the Verilog file is created, compile it using iverilog:\n!iverilog -o test.out test.v Now, run the compiled Verilog file using vvp:\n!vvp test.out If everything is working correctly, you should see the message \u0026ldquo;Hello, Icarus Verilog on Colab!\u0026rdquo; printed in the output.\nGenerating and Viewing Waveform Files In addition to printing messages, you can also generate waveform files to analyze signal behavior. This is particularly useful for debugging digital designs.\nTo generate a VCD (Value Change Dump) file, modify your Verilog code to include the necessary $dumpfile and $dumpvars commands:\n%%writefile wave.v module wave; initial begin $dumpfile(\u0026#34;wave.vcd\u0026#34;); $dumpvars(0, wave); $display(\u0026#34;Generating wave.vcd...\u0026#34;); #10; $finish; end endmodule Compiling and Simulating Compile and simulate the modified Verilog file using the following commands:\n!iverilog -o wave.out wave.v !vvp wave.out You should see a message confirming that wave.vcd has been generated.\nDownloading and Viewing the Waveform File Once the wave.vcd file is created, you can download it to your local machine for analysis using GTKWave, a popular waveform viewer. Use the following command to download the file:\nfrom google.colab import files files.download(\u0026#34;wave.vcd\u0026#34;) After downloading, open the file in GTKWave and inspect the signal transitions.\nDownload the Notebook You can download the Jupyter Notebook containing all the above steps from the following link:\nDownload the Jupyter Notebook\nConclusion Using Google Colab for Icarus Verilog simulations provides a simple and convenient way to write, compile, and debug Verilog code without requiring any local installations. Whether you\u0026rsquo;re a beginner learning Verilog or an experienced engineer testing small designs, this setup allows you to quickly prototype and verify your digital circuits.\nBy following the steps outlined in this guide, you can:\nInstall Icarus Verilog in Google Colab. Write and execute Verilog programs. Generate and analyze waveform files. This setup is especially useful for students, researchers, and hobbyists who need a hassle-free environment to experiment with Verilog without worrying about system configurations. Happy coding!\n","date":"February 24, 2025","image":"/images/post/iver/image_hu4920323439412474740.png","permalink":"/blog/setting-up-icarus-verilog-on-google-colab/","title":"Setting Up Icarus Verilog on Google Colab"},{"blog":["PID","RubiksCubeSolver","PID1","blog","s"],"contents":"The Rubik’s Cube is not just a puzzle; it’s a deep mathematical object grounded in group theory, combinatorics, and geometry. Understanding the math behind it allows us to grasp why it has 43 quintillion possible states, how we categorize moves, and why some solutions are more efficient than others.\nGroup Theory and the Rubik’s Cube Group theory is a branch of mathematics that studies sets with operations that follow specific rules. The Rubik’s Cube can be seen as a mathematical group where:\nEach state of the cube is an element of the group. Each valid move (rotating a face) is a group operation. The identity element is the solved state of the cube. Moves have inverses (e.g., turning the right face clockwise can be undone by turning it counterclockwise). The Rubik’s Cube belongs to a finite group since it has a limited number of positions. The set of all possible cube configurations, with the operation of applying a sequence of moves, forms a non-abelian group (meaning that order matters—doing move A then B is not the same as doing move B then A).\nHere’s the updated version incorporating center orientation in the usual order for 3×3 scales:\nOrder of an Element in the Rubik’s Cube Group In group theory, the order of an element is the number of times it must be applied to return to the identity (solved state). In the Rubik’s Cube, certain moves or sequences have different orders:\nA single quarter-turn of a face has order 4 (doing it four times returns the cube to the original state). A 180-degree turn has order 2. Certain complex sequences have higher orders, meaning they take more repetitions to cycle back to the starting position. On a standard 3×3 Rubik’s Cube, center pieces do not change position, but their orientation can matter in some cases, such as in supercube variants where sticker orientation is tracked. In such cases, center rotations may introduce elements of order 2 or 4, depending on the move sequence. Understanding the order of moves, including center orientation, helps in designing efficient solving algorithms.\nCounting the 43 Quintillion Permutations To compute the number of possible Rubik’s Cube states, we analyze the degrees of freedom:\nThere are 8 corner pieces, each of which can be arranged in (8!) ways. Each corner has three orientations, giving (3^7) possibilities (the last one is determined by the others). There are 12 edge pieces, which can be arranged in (12!) ways. Each edge has two orientations, giving (2^{11}) possibilities (the last one is determined by the others). However, only even permutations of corners and edges are possible, so we divide by 2. Thus, the total number of possible Rubik’s Cube states is:\n$$ \\frac{8! \\times 3^7 \\times 12! \\times 2^{11}}{2} = 43,252,003,274,489,856,000 $$\nwhich is approximately 43 quintillion.\nFor the 2×2×2 Rubik’s Cube, we use a similar method but without considering edges:\nThe 8 corner pieces can be arranged in (8!) ways. Each has 3 orientations, giving (3^7) (since the last one is determined). Only even permutations are possible, so we divide by 2. Thus, the number of possible 2×2×2 states is:\n$$ \\frac{8! \\times 3^7}{2} = 3,674,160 $$\nwhich is significantly smaller than the 3×3×3 but still quite large.\nGod’s Number and Move Metrics God’s Number is the maximum number of moves required to solve the worst-case scenario of a Rubik’s Cube optimally. In 2010, researchers proved that God’s Number for a standard 3×3×3 Rubik’s Cube is 20 moves in the quarter-turn metric (where each 90-degree face turn counts as one move).\nMove Metrics Quarter-Turn Metric (QTM): Every 90-degree turn is counted as one move. This is the standard used in the 20-move God’s Number proof. Half-Turn Metric (HTM): Both 90-degree and 180-degree turns count as one move. In this metric, God’s Number is 18 moves. Face-Turn Metric (FTM): Any rotation of a face, whether 90, 180, or 270 degrees, is counted as one move. Different solving methods optimize for different metrics. For example, speedcubers prioritize fewer moves in practice rather than the theoretical minimum number of moves.\nEuclidean and Quaternion Mathematics in the Rubik’s Cube Euclidean Geometry and the Rubik’s Cube The Rubik’s Cube exists in three-dimensional Euclidean space, meaning its transformations can be represented using classical geometric tools such as matrices and vector operations.\nRotation Matrices: Each face rotation can be described using a 3×3 rotation matrix. A 90-degree clockwise rotation about the x, y, or z-axis can be represented as:\n$$ R_x(90^\\circ) = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; -1 \\ 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix}, $$\n$$ R_y(90^\\circ) = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 1 \\ 0 \u0026amp; 1 \u0026amp; 0 \\ -1 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix}, $$\n$$ R_z(90^\\circ) = \\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0 \\ 1 \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}. $$\nVector Representation: Each cubie (small cube piece) has a position vector ( v ), and applying a rotation matrix transforms it to a new position: $$ v\u0026rsquo; = R v. $$ Using these transformations, all possible moves on the cube can be described mathematically.\nQuaternion Representation and the Rubik’s Cube Quaternions offer an alternative way to describe rotations in 3D space. A quaternion is defined as: $$ q = a + bi + cj + dk, $$ where ( a, b, c, d ) are real numbers, and ( i, j, k ) are imaginary unit vectors satisfying specific multiplication rules.\nRotation Using Quaternions: Any 3D rotation can be represented as: $$ q = \\cos\\left(\\frac{\\theta}{2}\\right) + \\sin\\left(\\frac{\\theta}{2}\\right)(xi + yj + zk), $$ where ( \\theta ) is the rotation angle, and ( (x, y, z) ) is the rotation axis.\nApplying a Rotation: Given a point represented by a quaternion ( p ), the rotated point ( p\u0026rsquo; ) is obtained as: $$ p\u0026rsquo; = q p q^{-1}. $$\nUsing quaternions avoids issues like gimbal lock and allows smooth, efficient calculations, making them useful in robotic cube solvers and computer simulations.\nComparison of Euclidean and Quaternion Methods Method Advantages Use Case in Rubik’s Cube Rotation Matrices Simple, easy to compute Manual cube manipulation, algebraic solving Quaternions No gimbal lock, computationally efficient Robotics, computer simulations While human solvers primarily use group-theoretic approaches, understanding Euclidean and quaternion mathematics is valuable for computational methods and AI-driven solutions.\nAdvanced Mathematics Behind the Rubik’s Cube Graph Theory and the Rubik’s Cube The entire state space of the Rubik’s Cube can be visualized as a graph, where:\nEach node represents a unique cube configuration. Each edge represents a valid move between two configurations. This allows us to analyze cube solving as a shortest path problem (like in Dijkstra’s algorithm). The challenge is that this graph is huge, containing about 43 quintillion nodes! Researchers have used Breadth-First Search (BFS) to explore how quickly the cube can be solved from any state, leading to the proof of God’s Number (20 in QTM).\nMarkov Chains and Random Scrambles If you randomly twist a Rubik’s Cube, how many moves does it take before it is \u0026ldquo;fully scrambled\u0026rdquo;? This is a classic Markov Chain problem, where each move represents a random transition between states. Studies suggest that after about 19-20 random moves, the cube is statistically close to a uniformly random state. This insight is used in competitive cubing to ensure fairness in official scramble generation.\nGroup Structure: Conjugacy Classes and Commutators The Rubik’s Cube group has special elements called commutators and conjugates, which are fundamental to advanced solving techniques:\nCommutator: ([A, B] = A B A^{-1} B^{-1}) – used in many algorithms to isolate cube pieces. Conjugate: (X A X^{-1}) – applies a transformation in a different context. These concepts allow cube solvers to move a small set of pieces without disrupting the rest, forming the basis for algorithms like CFOP, Roux, and ZZ methods.\nWhy Is Solving the Cube Hard? Computational Complexity Solving an arbitrary cube position optimally (in the least moves) is an NP-hard problem. That means there is no known efficient algorithm that can solve every case optimally in polynomial time. This is why human solvers use heuristic-based approaches like CFOP, Petrus, and Roux, rather than brute force computation.\nWhat’s Next? Computers and Efficient Cube Solving In our next post, we will explore how computers approach solving the Rubik’s Cube, including AI techniques, heuristics, and optimal solvers like Kociemba’s Algorithm and DeepCubeA.\n","date":"February 14, 2025","image":"/images/post/mathrub/image_hu11510849546453357576.png","permalink":"/blog/mathematics-behind-rubiks-cube/","title":"The Mathematics Behind the Rubik's Cube #PID1.3"},{"blog":["PID","RubiksCubeSolver","PID1","blog","s"],"contents":"\rThe Rubik’s Cube, with its intricate design and colorful chaos, can seem overwhelming at first glance. However, solving it is not just about memorizing algorithms but about understanding the mechanics behind each move. There are several well-known solving methods, each with its own advantages and techniques that cater to different solving styles. Whether you\u0026rsquo;re aiming for speed, efficiency, or ergonomic moves, the CFOP, Roux, and ZZ methods offer distinct paths to mastery. These are all speed-solving methods designed for competitive cubing, but there are also beginner-friendly and alternative approaches like the Layer-by-Layer (LBL) and Petrus methods.\nCFOP: The Classic Speedcubing Approach CFOP (Cross – First Two Layers – Orientation of Last Layer – Permutation of Last Layer), also known as the Fridrich Method, is the most widely used method among speedcubers. It breaks the solve into four logical steps, enabling high efficiency and minimal pause between sequences.\nThe Cross The first step is solving a cross on one face of the cube, typically white. The aim is to position the four edge pieces correctly while minimizing moves. Advanced solvers focus on efficiency, ensuring that each edge is inserted optimally without unnecessary cube rotations. Many speedcubers practice solving the cross in eight moves or fewer to optimize their solving time.\nFirst Two Layers (F2L) Rather than solving corners and edges separately, F2L pairs them up before inserting them into their respective slots. This is a crucial speed improvement over beginner methods, reducing move count significantly. F2L can be learned intuitively, but advanced cubers memorize key cases and algorithms for increased efficiency.\nOrientation of the Last Layer (OLL) Once the first two layers are completed, the next step is orienting all pieces on the top layer so that the face becomes a uniform color. There are 57 possible cases, but beginners can use a two-step OLL approach with just ten algorithms.\nPermutation of the Last Layer (PLL) The final step is to permute the last layer pieces into their correct positions. This step requires knowledge of 21 algorithms in the full PLL method or just six in the two-look PLL approach. Mastering PLL allows for faster transition times and optimized finger tricks to reduce execution delays.\nCFOP is the go-to method for many speedcubers because of its structured approach and ability to handle high turn-per-second (TPS) solves with ease. Even I use CFOP for solving the cube now—I do an intuitive cross and F2L, then use 2-look OLL and 1-look PLL.\nFor 2x2, I use the CLL (Corners Last Layer) method. You can check out my times here: Cubelelo Profile (it\u0026rsquo;s unofficial, but yeah!).\nRoux: The Efficient Block-Building Method Roux, developed by Gilles Roux in 2003, takes a vastly different approach from CFOP. It focuses on reducing move count and minimizing cube rotations, making it ideal for one-handed solving. Unlike CFOP, Roux relies heavily on intuitive solving techniques and block-building rather than strict algorithm memorization.\nFirst Block The solve begins by constructing a 1x2x3 block on one side of the cube. This is done by strategically placing the edge and corner pieces in the correct positions without disrupting already solved parts.\nSecond Block A second 1x2x3 block is then built on the opposite side of the cube. At this point, the left and right blocks are complete, leaving only the middle slice and top layer unsolved.\nCMLL (Corner Orientation \u0026amp; Permutation) Instead of solving the last layer in steps like OLL and PLL, Roux addresses all four corners at once using CMLL (Corners of the Last Layer). This step requires only 42 algorithms but can be broken into smaller subsets for easier learning.\nLSE (Last Six Edges) The final stage focuses on solving the remaining six edges using M and U moves exclusively. This step is what makes Roux unique, as it avoids rotations and allows for smooth, fast execution.\nThe strength of Roux lies in its efficiency—solves often require fewer moves than CFOP, and its reliance on intuitive solving makes it an excellent alternative for those who prefer a different approach.\nZZ: The Method Designed for Ergonomics The ZZ method, named after its creator Zbigniew Zborowski, aims to balance efficiency and turning ergonomics. It pre-orients edges early in the solve, allowing the rest of the cube to be solved with only R, U, and L moves, eliminating cube rotations and awkward finger placements.\nEOLine (Edge Orientation \u0026amp; Line) The solve begins by orienting all edges while placing two key edges along the bottom. This setup ensures that later steps can be executed smoothly without disrupting edge orientation.\nFirst Two Layers (F2L) Unlike CFOP, which requires cube rotations for F2L, the ZZ method allows for rotationless F2L execution. Because edge orientation was handled in EOLine, all remaining F2L pairs can be inserted using only R, U, and L moves.\nLast Layer Since all edges are already oriented, solving the last layer can be approached using CFOP-style algorithms or ZZ-specific techniques. The most advanced ZZ solvers use ZBLL (Zborowski-Bruchem Last Layer), which solves the entire last layer in one step, requiring knowledge of over 400 algorithms.\nZZ is an excellent choice for solvers who want to improve ergonomics while maintaining low move counts. However, EOLine can be challenging to master, making it slightly more difficult for beginners compared to CFOP.\nLayer-by-Layer (LBL): The Beginner-Friendly Method The Layer-by-Layer (LBL) method is the most common beginner method. It involves solving the cube in three distinct layers:\nSolve the first layer by completing a cross and inserting corners. Solve the second layer by inserting edge pieces into their correct slots. Solve the last layer using algorithms to orient and permute the pieces. This method is easy to learn and provides a solid foundation for more advanced techniques like CFOP.\nPetrus Method: The Block-Building Alternative The Petrus Method, developed by Lars Petrus, is a block-building approach that reduces move count and improves efficiency:\nSolve a 2x2x2 block anywhere on the cube. Expand it to a 2x2x3 block. Orient the edges early to make solving easier. Solve the remaining pieces with minimal moves. This method is useful for those who want an alternative to CFOP and prefer a more flexible solving approach.\nChoosing the Right Method Each method has its strengths, and the best one depends on your goals:\nCFOP is the best choice for speedcubers aiming for high TPS and efficiency. Roux is ideal for solvers who prefer intuitive solving and minimal rotations. ZZ is suited for those who want ergonomic solves with fewer rotations. LBL is great for beginners starting with the cube. Petrus is perfect for those who enjoy a block-building approach. No matter which method you choose, improving your lookahead, finger tricks, and efficiency will always be key to becoming a faster solver. Try out different approaches and see what works best for you!\nHappy cubing!\n","date":"February 7, 2025","image":"/images/post/solverubcub/poster_hu9180065793020124339.png","permalink":"/blog/solving-the-rubiks-cube/","title":"Solving The Rubiks Cube #PID1.2"},{"blog":["PID","RubiksCubeSolver","PID1","blog","s"],"contents":"The Rubik’s Cube is a 3D combination puzzle that has fascinated minds for decades. Invented in 1974 by Ernő Rubik, a Hungarian architect and professor, it was originally called the \u0026ldquo;Magic Cube.\u0026rdquo; Designed as a teaching tool to explain 3D movement, it quickly became a global sensation. The challenge? Scramble it, then restore each face to a single color—sounds simple, but millions have struggled (and succeeded) at it since!\nHow a Rubik’s Cube is Structured At first glance, the Rubik’s Cube appears to be just 27 smaller cubes arranged in a 3x3 grid, but its internal mechanics are far more sophisticated. The core mechanism allows for smooth rotations, holding everything together while letting the outer pieces move freely.\nThe cube consists of three main types of pieces:\nCore: The core holds the entire structure intact. It consists of six fixed center pieces that never move relative to each other. Edges: The cube has 12 edge pieces, each with two colors, positioned between the centers. Corners: There are 8 corner pieces, each with three colors, which determine the cube’s orientation. Each of these pieces interlocks in a way that allows rotation without disassembling the puzzle. When twisted, the cube rearranges itself by moving these smaller components around the core, yet the entire structure remains stable.\nHow It Rotates and Functions Despite its scrambled look, a Rubik’s Cube follows a well-structured mechanical system:\nEach face rotates independently, thanks to the internal core mechanism. The center pieces remain static, acting as reference points for solving. Edge and corner pieces move around freely, rearranging their positions to create new patterns with every turn. Each move you make affects multiple pieces at once, creating complex shifts that can be solved using known algorithms. The key is to understand how these pieces interact with each turn to work towards a solution.\nRubik’s Cube Notation (3x3 Standard Moves) To communicate Rubik’s Cube solutions, we use standard notation:\nFace Turns:\nR (Right) – Rotate the right face 90° clockwise R\u0026rsquo; (Right Prime) – Rotate the right face 90° counterclockwise L (Left) – Rotate the left face 90° clockwise L\u0026rsquo; (Left Prime) – Rotate the left face 90° counterclockwise U (Up) – Rotate the top face 90° clockwise U\u0026rsquo; (Up Prime) – Rotate the top face 90° counterclockwise D (Down) – Rotate the bottom face 90° clockwise D\u0026rsquo; (Down Prime) – Rotate the bottom face 90° counterclockwise F (Front) – Rotate the front face 90° clockwise F\u0026rsquo; (Front Prime) – Rotate the front face 90° counterclockwise B (Back) – Rotate the back face 90° clockwise B\u0026rsquo; (Back Prime) – Rotate the back face 90° counterclockwise Double Turns:\nMoves followed by 2 (e.g., R2, U2) indicate a 180° turn in either direction. This notation is used universally among cubers, making it easier to follow solving guides and algorithms.\nColor Schemes and Face Orientation Most official Rubik’s Cubes follow a standardized color arrangement, which helps speedcubers recognize patterns quickly. The opposite face pairs are usually:\nWhite ↔ Yellow Blue ↔ Green Red ↔ Orange This scheme remains consistent across most cubes, ensuring uniformity in solving strategies. Recognizing the relationship between opposite faces is crucial when learning solving techniques, as many algorithms rely on the cube’s color orientation.\nDifferent Types of Rubik’s Cubes and Modifications The classic 3x3 is just the beginning! There are countless variations, each adding its own twist to the challenge:\nNxN Cubes (Larger and Smaller Variants) 2x2 (Mini Cube) – A simpler version, great for beginners. 3x3 (Standard Cube) – The original and most popular. 4x4 (Rubik’s Revenge) – Extra layers mean extra complexity. 5x5 (Professor’s Cube) – More layers, more challenge. Even larger cubes like 6x6, 7x7, and beyond exist for advanced solvers. Shape Modifications Fisher Cube – A 3x3 shape mod that appears to shift its center axis, making it visually deceptive. Windmill Cube – Features diagonal cuts, making rotations feel unpredictable. Axis Cube – Turns into a bizarre, asymmetric mess when scrambled. Mirror Cube – Solved by shape instead of color, adding an extra challenge. Other Unique Cubes Pyraminx – A triangular-based twisty puzzle with simpler movement mechanics. Megaminx – A 12-sided dodecahedron cube with an extra layer of complexity. Ghost Cube – A shape-shifting cube that must be solved by aligning irregularly shaped pieces rather than colors. Each of these variations presents a unique solving challenge, keeping cubers engaged for years!\nFinal Thoughts The Rubik’s Cube is more than just a toy—it’s a mechanical marvel, a brain workout, and an endless source of fun. Whether you’re solving a classic 3x3 or diving into the wild world of modded cubes, the principles remain the same: patterns, patience, and persistence. Solving a Rubik’s Cube can enhance cognitive skills like problem-solving, pattern recognition, and spatial awareness, making it a fantastic hobby for all ages.\nSo, grab a cube, start twisting, and embrace the puzzle madness! 🔄✨\n","date":"January 31, 2025","image":"/images/post/rubcubemech/poster_hu18086298204613167302.png","permalink":"/blog/mechanics-of-rubiks-cube/","title":"Mechanics of Rubiks Cube #PID1.1"},{"blog":["PID","RubiksCubeSolver","PID1","blog","s"],"contents":"\rPuzzles. Whether it’s a crossword, Sudoku, or that infuriating jigsaw piece that just won’t fit, puzzles have a unique way of grabbing our attention and holding it hostage. But have you ever wondered why solving puzzles feels so satisfying? Beyond the fun, puzzles sharpen your mind, boost your problem-solving skills, and, let’s be honest, give you bragging rights.\nAt their core, puzzles are challenges—a structured way to ask, “How do I figure this out?” And that question is more important than you might think. Life, in many ways, is a giant puzzle: decisions, strategies, unexpected twists. The better we get at solving little puzzles, the more equipped we are for the big ones.\nWhy Solve Puzzles? Solving puzzles is like a gym session for your brain. They improve cognitive functions, boost memory, and enhance focus. But beyond brainpower, puzzles teach patience, perseverance, and the art of thinking outside the box—skills that are valuable in any field, from coding to cooking to simply navigating life.\nAnd let’s not forget the dopamine rush! Every solved puzzle is a small victory, and our brains love rewarding us for it. Who doesn’t like a mental high five?\nCoding: The Ultimate Mental Puzzle Now, let’s talk about coding—arguably one of the most satisfying puzzles you can tackle. Writing code is essentially solving a problem using logic, creativity, and a touch of wizardry. Each bug is a mini-puzzle, each feature a challenge to implement. And with coding puzzles, you’re not just solving; you’re building.\nFor those who’ve wrestled with algorithms, debugging, or optimizing code, you’ll agree: coding is a puzzle that never gets old. The beauty lies in its versatility. Problems evolve, solutions change, and the learning never stops.\nTwo Hands, One Brain: The Magic of Physical Puzzles Now, let’s take this a step further: puzzles that involve not just your mind but your hands too. Think about the Rubik’s Cube, where both hemispheres of your brain are engaged. The left brain loves the logical sequences and patterns, while the right brain enjoys the spatial awareness and creativity. It’s like a full-brain workout.\nPhysical puzzles improve hand-eye coordination, dexterity, and your ability to multitask. Plus, there’s something incredibly satisfying about manipulating an object and watching it transform under your hands. For me, working with physical puzzles has always been a humbling experience—you can’t brute force them; they demand focus and finesse.\nThe Rubik’s Cube: A Personal Journey Ah, the Rubik’s Cube—a classic that’s equal parts intriguing and intimidating. My first encounter with it was… chaotic, to say the least. Scrambling it was easy, but solving it? Let’s just say it took me more than a few attempts (and some YouTube tutorials) to get it right.\nBut once I did, it was magical. Solving a Rubik’s Cube is a dance of logic and intuition. It teaches you to think in layers, anticipate moves, and stay calm under pressure. And honestly, it’s just plain cool to whip one out and solve it in front of friends.\nPuzzles Meet Tech: The Rubik’s Cube Solver Now imagine combining the worlds of physical and digital puzzles. That’s exactly what we’ll be doing in the Rubik’s Cube Solver series. This project is a blend of hardware and software challenges—a perfect playground for anyone who loves puzzles.\nThe idea is to build a system that can solve a Rubik’s Cube autonomously. From understanding the cube’s mechanics to writing algorithms that optimize solutions, this project is as rewarding as it is complex. And here’s the best part: you’ll get to learn and build alongside me.\nNote: This project is still in its simulation phase. There are optimizations to be made, and the hardware implementation is yet to be completed. But that’s the beauty of this series—we’ll question every step, learn from every mistake, and inch closer to the solution together.\nIntroducing the PID Series The Rubik’s Cube Solver is just the beginning. The PID: Project IN Detail series is a deep dive into my projects, where I share insights, challenges, and breakthroughs. There’s a lot more to come, and I’m thrilled to have you along for the ride.\nIn the next few posts, we’ll start with the basics of solving a Rubik’s Cube—the foundational techniques that will help you tackle the puzzle manually. From there, we’ll explore how computers can do it better, faster, and with optimizations we can only dream of.\nWhy Wait? Let’s Get Started! Puzzles are more than a pastime; they’re a way of thinking, learning, and growing. Whether you’re a coding enthusiast, a Rubik’s Cube aficionado, or just someone who loves a good challenge, this series has something for you.\nSo grab a cube, roll up your sleeves, and let’s dive into the fascinating world of puzzles—one twist at a time.\n","date":"January 24, 2025","image":"/images/post/puzzles/puzzles_hu16412763637766407020.jpg","permalink":"/blog/why-should-you-start-solving-puzzles/","title":"Why Should You Start Solving Puzzles? #PID1.0"},{"blog":["personal","experience","blog","s"],"contents":"Last year, I missed ROSCon India due to exams and, honestly, had no idea what I was missing out on. This year, though, I made it, and it turned out to be more than I ever imagined. The two days I spent at ROSConIN'24 were nothing short of transformative, and this blog itself is a result of the inspiration I drew from the event.\nSetting the Stage The second edition of ROSCon India, following the overwhelming success of last year’s event with 750+ attendees, was hosted by ARTPARK at the Indian Institute of Science (IISc), Bangalore. This event brought together developers, hobbyists, researchers, and industry professionals to share, learn, and network over all things ROS (Robot Operating System).\nWhat makes ROSCon India special is its resemblance to the international ROSCon, with a local flavor that emphasizes India’s growing influence in robotics and automation. It was heartwarming to see support from Open Robotics and the enthusiastic efforts of Acceleration Robotics, RigBetel Labs, and ARTPARK in organizing such an impactful gathering.\nDay 0: Workshops Galore The event kicked off with Workshop Day on December 4th. We could choose one out of three workshops, and I opted for the third one:\nWorkshop 1: Next-Gen Robotics Development with NVIDIA ISAAC, GenAI, and ROS – Organized by NVIDIA, this workshop offered a comprehensive dive into cutting-edge robotics development. Though I couldn’t attend it, the buzz from the attendees made it clear how enriching it was.\nWorkshop 2: Leveraging Zenoh as a ROS 2 Middleware Layer – Conducted by Zettascale Technology, this session explored Zenoh as an innovative middleware layer for ROS 2. It intrigued many participants and opened up discussions on its potential.\nWorkshop 3: ROS 2 Controls, Navigation, and Advanced Communication Study – Organized by ARTPARK, this was my pick! A deep dive into ROS 2 controls, navigation, and communication felt perfectly aligned with my interests. The hands-on experience and insights I gained were invaluable.\nDay 1: A Conference to Remember December 5th began with registrations and a warm welcome address by the organizers, setting an enthusiastic tone. Some highlights from the day included:\nKeynotes: Geoffrey Biggs (CTO, Open Robotics) and Yadunund Vijay (Intrinsic) discussed the state of Open Robotics in 2024, followed by Jigar Halani from NVIDIA sharing insights on robotics development. Inspiring Talks: From Yuvraj Mehta’s session on RoboGPT to Sarvesh Kumar Malladi’s insights on Universal Robots’ ROS2 features, each talk added depth to the learning experience. Industry Focus: Anish Dalvi from TCS delved into automotive protocols, while Somdeb Saha highlighted retail automation with ROS. Both sessions demonstrated the vast industrial applications of ROS. Panel Discussion: The day ended with an engaging panel on cracking the product-market fit in robotics, featuring founders and investors sharing valuable insights. Day 2: Deep Dives and Future Directions December 6th brought more enlightening sessions, including:\nKeynote by Angelo Corsaro (ZettaScale Technology): An in-depth look at Zenoh as an alternative middleware layer for ROS 2. Technical Sessions: From Ajay Sethi and Prateek Nagras introducing the Robotics Application Stack to Nidhi Choudhary’s integration of physics-based neural networks with Gazebo, the variety of topics covered was astounding. Fireside Chat: The event concluded with a thought-provoking discussion on the future of ROS, featuring Geoffrey Biggs, Yadunund Vijay, and Angelo Corsaro. Networking and Personal Highlights One of the most fulfilling aspects of ROSConIN’24 was the chance to meet incredible people. I connected with alumni from my college, including Aryan Jaguste and Jatin Vera, whose experience in robotics left me inspired. I also met many other professionals who have been in this field for years, generously sharing their knowledge and encouraging me to keep learning and experimenting.\nIt was this vibrant exchange of ideas and stories that inspired me to start this blog. ROSConIN’24 wasn’t just a conference; it was a catalyst for my growth in the robotics domain.\nA Big Shoutout A massive thanks to all the companies and individuals who made this event possible, including Acceleration Robotics, RigBetel Labs, ARTPARK, NVIDIA, Zettascale Technology, Tata Consultancy Services, Universal Robots, and many others like Autodiscovery, Botsoverkill, Bullwork, Golain, I-Hub Jodhpur, IISc, Kikobot, Nawe, Neuralzome, Thundroids, Vicharak, Virya, and xTerra.\nClosing Thoughts As I reflect on my experience, I can’t help but marvel at how much this event has broadened my horizons. It’s not just about the technical knowledge but also the sense of community and the shared passion for innovation. If you’re even remotely interested in robotics or automation, attending ROSConIN should be a no-brainer. Who knows? You might walk away with a new project idea, a mentor, or even the inspiration to start a blog, just like I did!\nAs if ROSConIN’24 wasn’t enough to fill my plate with excitement, the very next day, I found myself at the GNOME Asia Summit in Bangalore. It was an incredible opportunity to connect with open-source contributors and Linux enthusiasts. The vibe there was equally inspiring, and I came away with even more appreciation for the open-source community.\nSpeaking of Bangalore, let’s not forget the city\u0026rsquo;s legendary traffic. I’ll admit, navigating those jam-packed streets tested my patience (and Google Maps’ sanity), but the morning chill and the sheer energy of being in India’s tech hub more than made up for it. If you’ve never tried squeezing in two major conferences in one trip, let me tell you—it’s like a crash course in networking and caffeine dependency.\nMeeting passionate individuals at both events has only fueled my curiosity to dive deeper into robotics and open source. In fact, it was during ROSConIN’24 that I felt inspired to start this tech blog, channeling my excitement and insights into something more tangible. And hey, if I can navigate Bangalore traffic and two back-to-back conferences, I’m pretty sure I can handle just about anything life throws my way!\n","date":"January 17, 2025","image":"/images/post/roscon/roscon_hu3821629981689278023.jpg","permalink":"/blog/my-rosconin24-experience/","title":"My RosConIN'24 Experience"},{"blog":["tips","blog","s"],"contents":"\rIn 2025, with the internet brimming with TikToks, reels, and AI-generated articles, you might wonder—is blogging still worth it?\nThe answer is a resounding YES, and here’s why.\nWhy Blog in 2025? Share Your Unique Perspective In a world of AI-generated content, your personal voice matters more than ever. AI might generate the basics, but stories, experiences, and personal insights are uniquely human. Whether you’re building your first robot, sharing parenting tips, or learning a new language, your journey can inspire others.\nThink about it: How many times have you Googled a problem, stumbled upon a blog, and found exactly what you needed? That could be you helping someone else.\nBuild Your Digital Legacy Your blog is your corner of the internet—a space to leave your mark. Unlike fleeting social media posts, blogs are evergreen, searchable, and build a record of your growth. For developers, it can be a portfolio of your work; for creatives, it’s a gallery of your creations.\nI started my blog to document my tech projects, but I realized it’s also helping me keep track of my ideas, progress, and experiments. Plus, I’ve already met people who share the same passions—thanks to this little space!\nLearn as You Share Writing is an incredible teacher. To explain something clearly, you need to truly understand it yourself.\nDevelopers often blog about solutions to bugs or coding techniques, which not only helps others but reinforces their own knowledge. For non-tech folks, writing about personal projects—whether it’s DIY, cooking, or fitness—gives clarity and keeps you motivated. Pro Tip: Blogging can make you a better problem-solver. Breaking down problems into digestible steps is the essence of both writing and coding.\nBuild Connections and Opportunities Blogging isn’t just about putting your thoughts into words; it’s about starting conversations. Your blog can:\nAttract collaborators who resonate with your ideas. Impress potential employers or clients by showcasing your expertise. Connect you with a like-minded community. Think of it as networking without the awkward handshakes.\nStay Relevant in the AI Era AI is great for automating tasks, but creativity, originality, and storytelling? That’s all you. A blog lets you flex those creative muscles and prove you’re not just keeping up with the times—you’re shaping them.\nWhy Students Should Start Blogging 🎓 As a student, blogging can be a game-changer for your personal and professional growth. Here’s why:\nShowcase Your Skills:\nYour blog can act as a dynamic portfolio. Whether it’s coding projects, research papers, or even creative writing, it’s a platform to demonstrate your expertise and passion. Employers and professors love seeing initiative.\nDocument Your Learning:\nWriting about what you’re learning—whether it’s a tough algorithm, a robotics project, or study hacks—helps reinforce your understanding and creates a resource for others.\nStand Out:\nIn a competitive world, a well-maintained blog sets you apart. It shows that you’re not just a passive learner but someone who actively contributes to the community.\nBuild Connections:\nBlogging opens doors to collaborations, internships, and mentorships. Sharing your work publicly can attract like-minded peers, professors, or even recruiters.\nPro Tip for Students: Start small. Write about a project or concept you recently worked on in class—it’s a great way to begin!\nHow to Start Blogging in 2025 If all this has convinced you, let’s talk about how to get started! Whether you’re a dev documenting code or someone sharing life hacks, blogging has never been easier.\nChoose Your Purpose Ask yourself: Why do I want to blog?\nIs it to document your journey (like me)? Share your expertise? Build a personal brand? Just for fun? Defining your purpose will help you stay motivated and give your blog a clear focus.\nPick the Right Platform Here are a few options to suit different needs:\nTechies: Use GitHub Pages for free hosting or platforms like Jekyll/Hugo for custom setups. Beginners: Try WordPress or Ghost—they’re user-friendly and have tons of templates. Minimalists: Substack or Medium are great for simple, distraction-free writing. What I Use: I opted for GitHub Pages because I love having full control over my blog’s look and feel.\nWrite What You Know (And Love) Find your niche. You don’t need to be an expert—just share your journey as you learn.\nDevs: Write about side projects, tutorials, or debugging solutions. Non-devs: Document hobbies, productivity hacks, or personal experiences. Remember: What’s obvious to you might be groundbreaking to someone else.\nKeep It Simple (At First) Don’t overcomplicate it. Your first post can be:\nAn introduction to who you are. A story about a project you worked on. A simple “lesson learned” post. It’s okay if your first post isn’t perfect—it’s better to start and improve as you go.\nLeverage AI to Help You In 2025, AI tools can make blogging easier:\nUse ChatGPT for brainstorming post ideas. Grammarly can polish your grammar. Tools like Jasper AI can even generate draft content. But remember: your voice is the star. AI can assist, but authenticity is irreplaceable.\nPromote Your Blog Once your blog is live, share it!\nPost about it on LinkedIn, Instagram, or Twitter. Join communities (Reddit, Discord, forums) related to your niche. Collaborate with others by guest-posting or linking to their work. If you’re consistent, people will notice.\nEmbrace the Process Blogging is a journey. Don’t stress about being perfect—just keep writing, experimenting, and learning. Tools like Google Analytics can show you what’s working and help you refine your style.\nFinal Thoughts Blogging in 2025 is about more than just writing—it’s about sharing your voice, building connections, and leaving a legacy. Whether you’re a coder, a hobbyist, or someone with a passion to share, there’s never been a better time to start.\nYour Blog, Your Rules: It doesn’t have to be fancy. It just has to be you.\nWhat’s Next? If you’re thinking of starting a blog, go for it! Your ideas are worth sharing. Feel free to reach out if you need help setting things up or brainstorming ideas—I’d love to hear from you.\nReady to take the plunge? Hit that \u0026ldquo;New Blog\u0026rdquo; button and let the world hear your voice!\n","date":"January 10, 2025","image":"/images/post/blog/why-blog_hu16664361137983714441.jpg","permalink":"/blog/why-blog-in-2025/","title":"Why Blog in 2025? (And How to Get Started)"},{"blog":["personal","blog","s"],"contents":"\rHello World! I’m Jagadeesh Mummana, and welcome to my blog dedicated to the fields of robotics, artificial intelligence, and various technological experiments I am engaged in.\nIf you have an interest in electronics, microcontrollers, or understanding technology, you may find the content here to be beneficial. My journey in this area has provided me with significant insights, and I believe it is time to document my experiences.\nPurpose of This Blog I started this blog mainly to organize and document what I’ve learned from various projects. A lot of my work tends to get buried in random folders on my laptop, and I figured sharing it here might make it more useful—not just for me, but maybe for others too.\nThis blog allows me to organize my thoughts, share what I have learned, and connect with others who share similar interests in technology. Additionally, I plan to commit to a weekly post every random day to maintain consistency in my exploration and reflection. If you\u0026rsquo;re interested in staying updated, consider subscribing to my newsletter on the right!.\nMotto: \u0026ldquo;Knowledge grows best when shared.\u0026rdquo; About Me I am currently a sophomore at NIT Calicut, pursuing a degree in Electronics and Communication Engineering with a minor in Robotics and Automation.\nI have a passion for constructing and deconstructing various systems to understand their functionality. My primary focus lies at the intersection of software and hardware, where innovative solutions often emerge.\nIt is important to note that I tend to have many ongoing projects simultaneously, which can sometimes hinder completion. I hope this blog serves as a motivation to follow through on more of these endeavors.\nCurrent Projects 🔍 I work on a lot of different projects, some finished, some still in progress. Here are just a few that reflect my interests—find all on my Projects Page.\nPR057H371C4RM – Prosthetic Arm This project involves creating a prosthetic arm that mimics finger movements using servos to create tension similar to biological tendons. Prosthetic Arm Prototype\rV-RU81K5CU83 (part of RU83C) – Virtual Rubik\u0026rsquo;s Cube Simulator This is a 3D Rubik’s Cube simulator designed in Unity, utilizing the Kociemba Solver to provide solutions based on the cube’s current configuration. Virtual Rubik\u0026rsquo;s Cube Simulator\rImProVe – Image Processing Using Verilog This project focuses on applying Verilog for image processing techniques such as edge detection and geometric transformations. Here are two spin-offs from this work: Label Detection Using Prewitt Operator\r- Label Detection: This involves utilizing the Prewitt and Canny edge detectors to identify label boundaries based on sudden intensity changes. Python is used to compile the results. - Document Scanner (In Progress): Building off the label detection principles, this project aims to identify the corners of a document and map these onto a rectangular frame. I aspire to incorporate Optical Character Recognition (OCR) for text extraction as well.\nNote: Some repositories are currently private due to various constraints. Should you have an inquiry about any of these projects, please feel free to reach out, and I will do my best to share what I can.\nFuture Directions In the near future, I aim to delve deeper into these projects by providing tutorials, lessons, and sharing insights from the challenges I encounter along the way.\nIf you have any suggestions for topics or projects that you would like to see discussed, please do not hesitate to contact me.\nLet’s Collaborate 🤝 If anything here caught your eye, or if you’ve got a project in mind you’d like to team up on, hit me up. Collaboration is one of the best ways to learn, and I’d love to hear what you’re working on too.\nConnect With Me 🌐 Here’s where you can find me: 🌌 Portfolio: mummanajagadeesh.github.io 💼 LinkedIn: Jagadeesh Mummana 🔧 GitHub: Mummanajagadeesh 📸 Instagram: @jagadeesh__97__ If any of this interests you, stick around! I’m always learning and trying new things, and I’d love to share that journey with you. Looking forward to exploring more together!\n","date":"January 3, 2025","image":"/images/post/hw/cat_hu12552715545416902655.gif","permalink":"/blog/hello-world/","title":"Hello World!!"}]