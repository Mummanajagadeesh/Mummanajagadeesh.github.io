[{"blog":["PID","RubiksCubeSolver","PID1","s","all"],"contents":"Kociemba’s algorithm revolutionizes Rubik’s Cube solving by efficiently navigating the immense complexity of the cube’s state space using advanced mathematical tools from group theory and heuristic search. This two-phase method strikes a balance between tractability and optimality, making it a cornerstone of computational puzzle solving.\nThe Mathematical Setup: Group Theory and Cosets Recall that the Rubik’s Cube group (G) consists of all legal cube states under composition of moves. Kociemba’s method strategically divides (G) into cosets of a carefully chosen subgroup (H \\subseteq G):\n$$ G = \\bigcup_{g \\in G/H} gH $$\nHere, (H) is the subgroup of cube states where all edges and corners are oriented correctly and all middle slice edges are located within the middle layer. This subgroup is sometimes called the \u0026ldquo;half-turn metric group\u0026rdquo;, since allowed moves in (H) correspond to half-turns of certain faces.\nBy reducing the problem to first finding the coset representative (g) that brings the cube into (H) (Phase 1), and then solving within (H) (Phase 2), the algorithm exploits the quotient structure (G/H) to manage complexity.\nPhase 1: Reducing to the Subgroup (H) Phase 1’s goal is to transform any scrambled cube state (s \\in G) into a state (s\u0026rsquo; \\in H) . Formally, find a sequence of moves (m_1) such that:\n$$ s\u0026rsquo; = m_1 \\cdot s \\in H $$\nWhere (m_1) is a product of face turns (quarter or half turns).\nEdge orientation: Each edge can be in two states — oriented or flipped — giving a binary invariant. There are (2^{12} = 4096) possible edge orientation states. Corner orientation: Each corner can be oriented in 3 ways, so (3^8 = 6561) corner orientations. Middle slice edges: The position of the four middle-layer edges is constrained. All these constraints define (H) , which contains approximately (10^{10}) states.\nPhase 1’s problem reduces to finding a minimal-length (m_1) to reach (H) , which is a constrained subgroup problem in the Rubik’s cube group.\nPhase 2: Solving within (H) Once the cube is in (H) , Phase 2 searches for a move sequence (m_2) restricted to moves within (H) such that:\n$$ m_2 \\cdot s\u0026rsquo; = I $$\nwhere (I) is the solved state.\nSince moves in (H) preserve edge and corner orientation and slice position, the search space is drastically smaller than the full (G) .\nHeuristics and Pattern Databases: Guiding the Search Direct brute-force search over (G) or even (H) is impossible due to the astronomical number of states. To tackle this, Kociemba’s algorithm employs heuristic search algorithms — specifically, Iterative Deepening A* (IDA*) — powered by pattern databases (PDBs).\nWhat are Pattern Databases? PDBs are precomputed lookup tables storing the exact minimal number of moves required to solve specific cube features, such as edge orientation or corner permutation, ignoring other features.\nFor example, one PDB might store the minimal moves to solve edge orientation, regardless of corner orientation or permutation.\nSince these databases cover disjoint subsets of the cube’s state, their heuristic values can be combined by taking the maximum to ensure admissibility (never overestimating).\nThis maximum value guides IDA* to explore only states promising to be close to the solution, pruning vast regions of the search space.\nIDA* Search Algorithm IDA* is a memory-efficient variant of A* that performs depth-first searches with increasing cost thresholds.\nAt each iteration:\nThe search depth limit is set by the heuristic cost (f = g + h) , where:\n(g) = cost from start to current node (number of moves so far) (h) = heuristic estimate of moves to goal (from PDB) The algorithm explores all nodes with (f \\leq) threshold.\nIf no solution found, threshold increases, and search repeats.\nIDA*’s use in Kociemba’s algorithm ensures that:\nThe first solution found is guaranteed to be minimal within the move restrictions. Memory overhead remains manageable, even for large state spaces. Formalizing the Heuristic Function If we define heuristic functions:\n(h_{EO}(s)): minimal moves to solve edge orientation in state (s) (h_{CO}(s)): minimal moves to solve corner orientation (h_{EP}(s)): minimal moves to place edges in their correct slices (h_{CP}(s)): minimal moves to permute corners correctly Then the combined heuristic (h(s)) guiding the search is:\n$$ h(s) = \\max { h_{EO}(s), h_{CO}(s), h_{EP}(s), h_{CP}(s) } $$\nThis ensures the search never expands nodes that cannot lead to an optimal solution.\nSummary of the Mathematical Power Kociemba’s algorithm elegantly balances:\nAlgebraic structure: Using subgroup and coset decompositions to reduce complexity Heuristic efficiency: Pattern databases provide admissible heuristics guiding the search Search algorithm: IDA* ensures optimal paths under given constraints This synergy enables the solver to consistently find solutions averaging around 20 moves (half the move length of Thistlethwaite’s original algorithm) in milliseconds on modern computers — a feat that would be impossible without this deep mathematical foundation.\nOther Algorithms: A Brief Overview and Comparison While Kociemba’s algorithm is among the most widely used for computational Rubik’s Cube solving due to its efficiency and near-optimal solutions, it is part of a broader landscape of methods, each with its own mathematical basis, advantages, and limitations.\nThistlethwaite’s Algorithm Revisited As discussed earlier, Thistlethwaite’s algorithm partitions the cube group into a sequence of four nested subgroups:\n$$ G = G_0 \\supset G_1 \\supset G_2 \\supset G_3 \\supset G_4 = { I } $$\nBy solving the cube progressively through these subgroups, it guarantees a solution in at most 52 moves (in half-turn metric). While theoretically elegant, the multiple phases and larger intermediate state spaces make it computationally heavier compared to Kociemba’s two-phase approach.\nGod\u0026rsquo;s Algorithm God’s Algorithm is the theoretical ideal that always finds the shortest possible solution for any cube position. It relies on exhaustive search of the entire state space ((\\approx 4.3 \\times 10^{19}) states) using massive computational resources and precomputed tables, such as the famous Table of 20 moves or less (God’s Number = 20).\nWhile this guarantees the absolute shortest solution, it is impractical for general use due to storage and computation demands. Kociemba’s algorithm often approximates God’s Algorithm efficiently by using heuristics and subgroup constraints.\nCFOP (Fridrich Method) On the practical speedcubing side, CFOP (Cross, F2L, OLL, PLL) is a human method rather than a computer algorithm. It relies on heuristic algorithms and pattern recognition rather than exhaustive search or mathematical group theory. While CFOP solves the cube very fast for humans, its move counts tend to be longer and less optimized compared to computational methods like Kociemba’s.\nOther Computational Approaches Korf’s Algorithm: Utilizes IDA* with large pattern databases for optimal solutions but is computationally expensive. Macro-Operators and Pruning Tables: Many solvers employ precomputed tables for specific cube configurations or use machine learning to predict move sequences. Genetic Algorithms and AI: Recent work explores reinforcement learning and evolutionary strategies to solve cubes without explicit group theory, focusing on policy learning and move prediction. Comparison Summary Algorithm Move Optimality Computational Complexity Use Case God’s Algorithm Guaranteed minimal Very high Theoretical, research Kociemba’s Algorithm Near-optimal (~20 moves) Moderate Fast, practical solvers Thistlethwaite’s Moderate (~52 moves max) Higher Theoretical, educational CFOP Longer (~50+ moves) Low Human speedcubing Korf’s Algorithm Optimal Very high Small subsets or specific puzzles Final Thoughts The mathematical sophistication of Rubik’s Cube algorithms reveals how computers transform the art of puzzle-solving. From the elegant subgroup decompositions of Thistlethwaite and Kociemba to heuristic-guided searches, computers convert what once was a purely human trial-and-error activity into a rigorous, near-optimal science.\nUnderstanding these algorithms highlights the power of:\nAlgebraic abstractions (groups, cosets) to simplify complex states Heuristic functions to efficiently guide searches Iterative search algorithms that balance time and space constraints In the next post, we will delve deeper into practical implementations of Kociemba’s algorithm and how modern solvers leverage these concepts to provide instant solutions.\n","date":"March 18, 2025","image":"/images/post/comprub/kociemba_hu_7c43bb21f01a60c0.png","permalink":"/blog/kociembas-alg-the-2-phase-breakthrough/","title":"Kociemba’s Algorithm – The Two-Phase Breakthrough #PID1.5"},{"blog":["PID","RubiksCubeSolver","PID1","s","all"],"contents":"Throughout history, puzzles have intrigued the human mind, not merely for entertainment but for the challenge they pose to logic, creativity, and persistence. From ancient labyrinths to Sudoku and the Rubik’s Cube, solving a puzzle often feels like an art — but beneath that art lies a surprising amount of structure. And where there is structure, computers can often outperform intuition.\nAt their core, puzzles are problems with constraints, and solving them requires a systematic approach to navigating possibilities. This is precisely the realm where computers shine. Unlike humans, computers are not limited by short-term memory, fatigue, or bias. They can execute algorithms tirelessly, evaluate vast search spaces, and spot patterns at a scale impossible for the human brain. As a result, computers don’t just mimic human puzzle-solving — they fundamentally transform it.\nWhy the Rubik’s Cube? Among all puzzles, the Rubik’s Cube has emerged as a particularly fascinating object of study in computer science, mathematics, and algorithm design. Invented in 1974 by Ernő Rubik, it has over 43 quintillion unique configurations (43,252,003,274,489,856,000 to be exact). That’s more than the number of grains of sand on Earth or seconds since the Big Bang. And yet, with the right approach, any configuration can be solved in 20 moves or fewer — a result known as God’s Number.\nBut how does one go from a jumbled cube to the solution in such a short number of moves, especially when the total number of configurations is so massive?\nThis is where the mathematical beauty of the cube comes into play.\nThe Mathematics Behind the Cube To a computer scientist or a mathematician, the Rubik’s Cube is more than just a toy — it\u0026rsquo;s a group. In group theory (a branch of abstract algebra), we define a group as a set with an operation that satisfies certain axioms: closure, associativity, identity, and inverses. Each move you make on a Rubik’s Cube — whether it’s a quarter-turn of a face or a full rotation — corresponds to an operation in this group.\nThe entire set of all possible cube states forms a permutation group. More specifically, it\u0026rsquo;s a subgroup of the symmetric group on the cube’s stickers, where each legal operation is a permutation of the cube’s pieces. The solved state is the group’s identity element, and solving the cube is equivalent to finding the inverse sequence of moves that returns any configuration to this identity.\nFrom a computational perspective, this means that solving the cube becomes a path-finding problem in a highly structured space. The “nodes” are the cube states, and the “edges” are the moves that transform one state into another.\nBut this graph of states is unimaginably vast — far too large for brute force to be practical. Even if a computer could check a billion configurations per second, it would still take centuries to exhaustively search all 43 quintillion. Clearly, we need something smarter.\nWhy Brute Force Fails — and Algorithms Succeed Imagine trying to solve the cube purely by random moves — it would be virtually impossible to land on the solved state, even in a lifetime. Even a depth-limited brute-force search, where the computer tries all sequences up to, say, 20 moves, quickly becomes intractable. At 18 legal face turns per move and 20 moves deep, that’s 18²⁰ ≈ 10²⁵ possibilities — still far beyond what any computer can handle.\nThat’s why we need algorithms. Algorithms introduce structure, allowing us to prune the search space intelligently. They leverage mathematical symmetries, identify key cube properties (like orientation, permutation, and parity), and break the problem into smaller, tractable sub-problems.\nRather than treating all configurations as equal, a good algorithm guides the computer through the space more like a mountaineer scaling peaks via well-worn trails rather than hacking blindly through a jungle.\nWhat Computers Bring to Puzzle Solving So why are computers particularly well-suited to this domain?\nSpeed: Computers can simulate millions of cube manipulations per second. Memory: They can store large lookup tables — precomputed solutions to subproblems. Exhaustiveness: They don’t get bored or distracted; they follow through every branch of a search tree. Precision: No errors, no forgetfulness. Every move is logical, every decision traceable. These strengths allow computers not only to solve the Rubik’s Cube but to solve it optimally — finding the shortest or most efficient solution using algorithmic planning.\nFrom Human Intuition to Mathematical Algorithms Before computers entered the scene, cube-solving was based largely on heuristics — trial-and-error, memorized sequences, and intuition. Speedcubers developed methods that worked well in practice but didn’t guarantee minimal solutions. It was the introduction of mathematical algorithms that changed the landscape.\nThe first major breakthrough came in the form of Thistlethwaite’s algorithm in the 1980s. It introduced the idea of reducing the cube\u0026rsquo;s complexity gradually by defining nested subgroups. From there, even more optimized approaches like Kociemba’s algorithm emerged, leveraging symmetries and lookup tables to reduce average solutions to around 20 moves.\nEach of these algorithms doesn’t just find a solution — they exploit the cube’s algebraic structure to find efficient, systematic paths through its vast configuration space.\nCertainly. Here\u0026rsquo;s the Thistlethwaite section, building directly upon the introduction and diving deep into the mathematical foundations behind it — particularly focusing on group theory, subgroup chains, and state space reduction:\nThistlethwaite’s Algorithm – From Chaos to Structure By the early 1980s, the Rubik’s Cube had become a global phenomenon — and a challenge that captivated not only hobbyists but also mathematicians. One such mind was Morwen Thistlethwaite, a mathematician who, in 1981, proposed one of the first major algorithmic breakthroughs in cube solving. His approach laid the foundation for many of the advanced solvers used today — not by brute force, but by applying the elegant machinery of group theory.\nAt its core, Thistlethwaite’s method turns the Rubik’s Cube into a layered mathematical structure — reducing the problem not in one step, but through a sequence of increasingly constrained subproblems. Each stage progressively shrinks the space of possible cube states, leveraging nested subgroups to transform an otherwise intractable problem into one that can be solved efficiently.\nModeling the Cube as a Group To understand Thistlethwaite’s insight, we first need to recognize how the cube operates in algebraic terms.\nEvery legal move on a Rubik’s Cube can be considered a group generator — a function that permutes the pieces of the cube. The entire collection of these permutations forms a group G under function composition. This group is known as the Rubik\u0026rsquo;s Cube group, and it contains all 43 quintillion possible cube states.\nMathematically, a group (G) can be described by a presentation — a set of generators (moves) and relations (how these moves interact). In the cube\u0026rsquo;s case, common generators might include:\n(U): rotate the upper face 90° clockwise (R): rotate the right face 90° clockwise (F): front face, and so on From just these generators and their inverses, all cube states can be reached.\nThe Key Insight: Subgroup Reduction Thistlethwaite’s key insight was to partition the problem of solving the cube into a sequence of four nested subgroups:\n$$ G_0 \\supset G_1 \\supset G_2 \\supset G_3 \\supset G_4 = { I } $$\nWhere:\n(G_0): the full cube group (all states) (G_1): subgroup where edge orientations are correct (G_2): subgroup where corners are also oriented (G_3): subgroup where all pieces are in correct slice layers (G_4): the identity group — the solved state Each subgroup (G_{i+1}) is a proper subgroup of (G_i), meaning it contains fewer states, but is still closed under certain restricted moves.\nFor example:\nTo move from (G_0)to (G_1), we only use moves that don\u0026rsquo;t disturb solved edge orientations. From (G_1) to (G_2), we constrain the move set further to preserve both edge and corner orientations. By progressing through these subgroups, the algorithm ensures that with each phase, the cube becomes increasingly constrained — gradually forcing it into a state where the solution becomes trivial.\nPhase-by-Phase Breakdown Let’s briefly outline the four phases of Thistlethwaite’s algorithm:\nPhase 1: Reduction to (G_1) Objective: Correct the orientation of all 12 edges.\nMove set allowed: all face turns Edge orientation is a binary invariant (flipped or not) The space of states reduces from ~(4.3 \\times 10^{19}) to about (10^9) Phase 2: Reduction to (G_2) Objective: Correct the orientation of corners and place all edges in their correct slice layers (middle or outer).\nMove set restricted to half-turns on some faces (e.g., only U, D, R2, L2, F2, B2) Corner orientation: 3 values per corner (0°, 120°, 240°) State space drops to ~(10^7) Phase 3: Reduction to (G_3) Objective: Place all pieces (edges and corners) in their correct orbits (positions relative to centers).\nOnly even permutations are allowed Reduction to ~(10^5) possible states Phase 4: Solve the cube (from (G_3) to identity) Objective: Use only the remaining allowed moves to reach the solved state.\nAt each stage, Thistlethwaite’s method restricts the move set, guiding the cube closer to a structured state while simultaneously reducing the number of legal transformations — and therefore the size of the search space.\nWhy It Works: Mathematics Meets Efficiency This hierarchical decomposition is more than a clever trick. It relies on coset decomposition from group theory. If we think of the Rubik’s Cube group (G) as a forest of interconnected trees, Thistlethwaite’s method picks one “layer” of branches at a time, cutting off all but the ones that eventually lead to the root (solved state). This avoids wandering aimlessly through the forest and allows for guided, phase-wise convergence.\nAnother advantage is modularity. Since each phase has a much smaller state space, it becomes feasible to precompute lookup tables (called pruning tables) for each subgroup. These tables store the shortest number of moves needed to reach the next subgroup from any configuration in the current one — dramatically reducing computation time during solving.\nConclusion Although Thistlethwaite’s algorithm does not always find the absolute shortest solution (i.e., not always “God’s Algorithm”), it typically solves any scrambled cube in 45 to 52 moves — a remarkable feat considering the cube’s astronomical complexity.\nThistlethwaite’s algorithm laid the groundwork for efficient Rubik’s Cube solving by breaking down the problem into manageable phases — next, we’ll explore how Kociemba’s algorithm builds on this foundation to achieve even faster and shorter solutions.\n","date":"March 7, 2025","image":"/images/post/comprub/image_hu_94ff828ee63517a.png","permalink":"/blog/computers-in-the-art-of-solving-puzzles/","title":"How Do Computers Come into the Art of Solving Puzzles? #PID1.4"},{"blog":["tips","hugo","site","s","all"],"contents":"Hugo is a fast, flexible, and open-source static site generator that allows you to build websites with ease. Originally popular for blogging, Hugo’s versatility makes it ideal for creating a wide range of sites — from personal portfolios and academic project showcases to documentation hubs and even e-commerce sites. Whether you’re building a professional portfolio, a research site to share your academic work, or a personal blog, Hugo has you covered.\nThis guide will take you through the entire process of building a website using Hugo, from installation to deployment, with practical tips to make your site look professional and unique.\n1. Install Hugo macOS (using Homebrew) If you\u0026rsquo;re on macOS and have Homebrew installed, this is the easiest way to install Hugo:\nbrew install hugo Windows (using Chocolatey) For Windows, use the Chocolatey package manager:\nchoco install hugo -confirm Linux (Debian/Ubuntu) If you\u0026rsquo;re on Linux, use the following commands to install Hugo:\nsudo apt-get update sudo apt-get install hugo Alternatively, you can download a precompiled binary for your platform from the Hugo releases page and extract it manually.\nVerifying Installation Once installed, verify the installation by running:\nhugo version This will show the version of Hugo you have installed, confirming that it is ready to go.\n2. Create a New Hugo Site After Hugo is installed, you can create a new site with a simple command. Open a terminal (or command prompt on Windows) and run the following:\nhugo new site \u0026lt;your-site-name\u0026gt; This creates a new directory (\u0026lt;your-site-name\u0026gt;) with the basic structure of a Hugo site. You’ll see directories like content/, layouts/, and themes/.\n3. Choose and Install a Theme Hugo uses themes to determine how your website looks. To browse available themes, head to the Hugo Themes website. There are hundreds of free and open-source themes to choose from.\nOnce you\u0026rsquo;ve chosen a theme, you can add it to your site by following these steps:\nUsing Git Submodule (Recommended) Inside your Hugo site directory, initialize a Git repository (if it isn’t already initialized):\ngit init Add the theme as a submodule:\ngit submodule add \u0026lt;theme-repository-url\u0026gt; themes/\u0026lt;theme-name\u0026gt; git submodule update --init --recursive Configure your site to use the new theme. Open config.toml (or config.yaml or config.json, depending on your configuration format) and set the theme:\ntheme = \u0026#34;\u0026lt;theme-name\u0026gt;\u0026#34; Alternatively, you can download the theme manually, but using Git submodules is more efficient for managing updates.\n4. Understanding Hugo’s Directory Structure Hugo uses a specific directory structure to organize your website’s content, assets, and configuration. Here\u0026rsquo;s a breakdown of the most important directories and files:\ncontent/: Where your content lives. This is where you will add markdown files for posts, pages, and other content types. themes/: Contains the themes you use in your site. Each theme will have a layouts/ directory, which contains the theme’s templates. static/: This directory holds static assets like images, CSS, JavaScript files, etc. Files here are copied directly to the root of the public/ directory when Hugo generates the site. layouts/: This folder is used for your custom templates. You can override theme templates or create your own templates for specific types of content. config.toml (or config.yaml, config.json): This is your site’s configuration file, where you set global parameters like the site’s title, base URL, language, theme, and more. 5. Create and Organize Content Now it’s time to add content to your website. You can create content types like blog posts, pages, or custom content.\nCreating a New Page or Post To create a new page or post, run the following command:\nhugo new \u0026lt;content-type\u0026gt;/\u0026lt;page-name\u0026gt;.md For example, to create a blog post:\nhugo new posts/my-first-post.md This will create a markdown file in content/posts/my-first-post.md.\nMarkdown Syntax for Content In the generated .md file, you\u0026rsquo;ll see frontmatter and markdown content:\n--- title: \u0026#34;My First Post\u0026#34; date: 2025-04-02 draft: true --- # Welcome to my blog! This is a simple markdown file to demonstrate Hugo. The frontmatter (between the --- lines) contains metadata for your content. You can set fields like title, date, draft, and custom parameters like tags or author. The content section uses standard markdown syntax. You can write paragraphs, lists, headings, links, images, and much more. Publishing Content Once you’re ready to publish, you can set draft: false in the frontmatter and run hugo server to preview the site.\n6. Start the Development Server To see your site in action, you can run a local development server:\nhugo server By default, this will run a server on http://localhost:1313. As you modify content or templates, Hugo will automatically regenerate the site and refresh the page.\n7. Building the Site for Production When you\u0026rsquo;re satisfied with your site, you can build it for production. Run the following command:\nhugo This will generate the static website in the public/ directory. The public/ directory will contain all the HTML files, assets, and other content required to host your site.\n8. Deploying the Site Once your site is built, you can deploy it to a variety of hosting platforms. Hugo sites are static, so they can be deployed on platforms like:\nGitHub Pages: You can push the contents of the public/ directory to a GitHub repository and serve it using GitHub Pages. Netlify: A popular static site hosting platform. Just link your GitHub repository to Netlify, and it will automatically build and deploy your site. Vercel: Another static site hosting platform similar to Netlify. Your Own Server: If you have a hosting provider or VPS, you can upload the files in the public/ directory to your web server. Each hosting platform will have specific instructions for deploying Hugo sites, but most of them integrate easily with Git-based workflows.\n9. Customizing Your Site Creating Custom Layouts To modify the look and feel of your site, you can create custom templates in the layouts/ directory. You can override default templates from the theme by placing your custom templates here.\nFor example, to modify the homepage layout, you can create layouts/index.html or layouts/_default/baseof.html to adjust the base layout structure.\nAdding Shortcodes Hugo supports shortcodes, which are snippets of reusable content. You can use shortcodes to easily insert dynamic elements like galleries, videos, or calls to action. Here’s an example of using a shortcode to embed a YouTube video:\nShortcodes can be defined in the layouts/shortcodes/ directory.\n10. Additional Tips Taxonomies: You can organize content using taxonomies like categories or tags. Add this configuration in config.toml:\n[taxonomies] category = \u0026#34;categories\u0026#34; tag = \u0026#34;tags\u0026#34; Multilingual Sites: Hugo supports multilingual sites. You can define different content for different languages in the content/ folder, such as content/en/ and content/es/.\nHugo Modules: Hugo also supports modules, which allow you to manage external dependencies in your site, such as themes or libraries.\nGitHub Actions: You can automate your Hugo build and deployment process using GitHub Actions for continuous deployment.\nConclusion Hugo is a powerful tool for building fast, static websites. With this guide, you should now be able to create, customize, and deploy your own Hugo-powered site. Whether you\u0026rsquo;re building a blog, portfolio, or documentation site, Hugo\u0026rsquo;s flexibility and speed make it a fantastic choice for modern static websites.\nHappy building!\nQuick Note: The site you’re reading this from is also built using Hugo — but with a ton of tweaks to make it uniquely mine! I started with the Geeky-Hugo theme as the base and added a bunch of customizations, including:\nCustom Layouts: Modified to fit my style and content structure.\nShortcodes: Added some handy ones for embedding interactive elements.\nCustom CSS: To give it a personal touch and make it look just right.\nLaTeX Support: For displaying complex mathematical equations seamlessly.\nExtended Pages: Not just limited to blogs — I’ve got project showcases, technical documentation, and more.\nIt’s proof that Hugo isn’t just about simple blogs — with some effort, you can turn it into a full-fledged portfolio or academic site!\n","date":"March 1, 2025","image":"/images/post/hugo/image_hu_eb040022dbb85df.png","permalink":"/blog/getting-started-with-hugo/","title":"Getting Started with Hugo: A Step-by-Step Guide"},{"blog":["tips","verilog","s","all"],"contents":"Google Colab is a cloud-based platform that allows you to run code in a Jupyter Notebook environment. While it\u0026rsquo;s primarily designed for Python, it can also be adapted to run Verilog simulations using Icarus Verilog. This guide walks you through setting up Icarus Verilog on Colab, writing and compiling Verilog code, running simulations, and generating waveform files for debugging—all in the cloud.\nYou might wonder why we’d even consider simulating Verilog code on Colab when there are many industry-grade tools available that offer synthesis, timing analysis, and complete hardware design capabilities. The answer lies in accessibility. Icarus Verilog is an open-source, lightweight alternative that remains incredibly relevant—especially for students, educators, and hobbyists. It’s perfect for academic projects, quick prototyping, and learning digital design fundamentals without the overhead of licensed tools or heavy installations.\nOne major advantage of using Colab is its seamless integration with the web—allowing you to import datasets or files directly from URLs or cloud storage. This becomes particularly useful for projects where Verilog testbenches need structured data, such as input vectors, weights, or test cases. With Python handling the preprocessing and formatting, you can easily generate files that your Verilog code can read, enabling a smooth and flexible software-hardware co-design workflow.\nMy own journey into this setup began with a somewhat unconventional idea: training a neural network in Verilog. It was a fun and technically challenging experiment that led me to build this workflow on Colab. If you\u0026rsquo;re curious to see how that turned out, feel free to check out my project here.\nWhy Use Icarus Verilog on Google Colab? Icarus Verilog is an open-source Verilog simulation and synthesis tool that supports a wide range of Verilog constructs. Running it on Google Colab offers several advantages:\nNo need to install software on your local machine. Easy collaboration and sharing through Colab notebooks. Accessible from any device with an internet connection. Free computational resources provided by Google. Now, let\u0026rsquo;s get started with setting up Icarus Verilog on Google Colab.\nInstalling Icarus Verilog Before you can run Verilog simulations, you need to install Icarus Verilog on your Colab environment. To do this, execute the following commands:\n!sudo apt-get update !sudo apt-get install -y iverilog Once installed, verify the installation by checking the version:\n!iverilog -v If the installation is successful, you will see the version information displayed in the output.\nWriting and Running a Simple Verilog Program To test if Icarus Verilog is working correctly, let\u0026rsquo;s write a simple Verilog program that prints a message. In Colab, you can use the %%writefile magic command to create and save Verilog files:\n%%writefile test.v module hello; initial begin $display(\u0026#34;Hello, Icarus Verilog on Colab!\u0026#34;); $finish; end endmodule Compiling and Running the Verilog Code Once the Verilog file is created, compile it using iverilog:\n!iverilog -o test.out test.v Now, run the compiled Verilog file using vvp:\n!vvp test.out If everything is working correctly, you should see the message \u0026ldquo;Hello, Icarus Verilog on Colab!\u0026rdquo; printed in the output.\nGenerating and Viewing Waveform Files In addition to printing messages, you can also generate waveform files to analyze signal behavior. This is particularly useful for debugging digital designs.\nTo generate a VCD (Value Change Dump) file, modify your Verilog code to include the necessary $dumpfile and $dumpvars commands:\n%%writefile wave.v module wave; initial begin $dumpfile(\u0026#34;wave.vcd\u0026#34;); $dumpvars(0, wave); $display(\u0026#34;Generating wave.vcd...\u0026#34;); #10; $finish; end endmodule Compiling and Simulating Compile and simulate the modified Verilog file using the following commands:\n!iverilog -o wave.out wave.v !vvp wave.out You should see a message confirming that wave.vcd has been generated.\nDownloading and Viewing the Waveform File Once the wave.vcd file is created, you can download it to your local machine for analysis using GTKWave, a popular waveform viewer. Use the following command to download the file:\nfrom google.colab import files files.download(\u0026#34;wave.vcd\u0026#34;) After downloading, open the file in GTKWave and inspect the signal transitions.\nDownload the Notebook You can download the Jupyter Notebook containing all the above steps from the following link:\nDownload the Jupyter Notebook\nConclusion Using Google Colab for Icarus Verilog simulations provides a simple and convenient way to write, compile, and debug Verilog code without requiring any local installations. Whether you\u0026rsquo;re a beginner learning Verilog or an experienced engineer testing small designs, this setup allows you to quickly prototype and verify your digital circuits.\nBy following the steps outlined in this guide, you can:\nInstall Icarus Verilog in Google Colab. Write and execute Verilog programs. Generate and analyze waveform files. What\u0026rsquo;s more—Colab isn\u0026rsquo;t just limited to Verilog. With a bit of setup, you can manage a range of open-source tools like Yosys, Graywolf, and many components from the OpenROAD flow, with GUIs disabled. This opens the door to enabling a full end-to-end digital design workflow—all within the cloud.\nThis setup is especially useful for students, researchers, and hobbyists looking for a hassle-free environment to explore digital design, without worrying about system configurations or heavy installations.\nHappy coding!\n","date":"February 24, 2025","image":"/images/post/iver/image_hu_f855b95485639afe.png","permalink":"/blog/setting-up-icarus-verilog-on-google-colab/","title":"Setting Up Icarus Verilog on Google Colab"},{"blog":["PID","RubiksCubeSolver","PID1","s","all"],"contents":"The Rubik’s Cube is not just a puzzle; it’s a deep mathematical object grounded in group theory, combinatorics, and geometry. Understanding the math behind it allows us to grasp why it has 43 quintillion possible states, how we categorize moves, and why some solutions are more efficient than others.\nGroup Theory and the Rubik’s Cube Group theory is a branch of mathematics that studies sets with operations that follow specific rules. The Rubik’s Cube can be seen as a mathematical group where:\nEach state of the cube is an element of the group. Each valid move (rotating a face) is a group operation. The identity element is the solved state of the cube. Moves have inverses (e.g., turning the right face clockwise can be undone by turning it counterclockwise). The Rubik’s Cube belongs to a finite group since it has a limited number of positions. The set of all possible cube configurations, with the operation of applying a sequence of moves, forms a non-abelian group (meaning that order matters—doing move A then B is not the same as doing move B then A).\nHere’s the updated version incorporating center orientation in the usual order for 3×3 scales:\nOrder of an Element in the Rubik’s Cube Group In group theory, the order of an element is the number of times it must be applied to return to the identity (solved state). In the Rubik’s Cube, certain moves or sequences have different orders:\nA single quarter-turn of a face has order 4 (doing it four times returns the cube to the original state). A 180-degree turn has order 2. Certain complex sequences have higher orders, meaning they take more repetitions to cycle back to the starting position. On a standard 3×3 Rubik’s Cube, center pieces do not change position, but their orientation can matter in some cases, such as in supercube variants where sticker orientation is tracked. In such cases, center rotations may introduce elements of order 2 or 4, depending on the move sequence. Understanding the order of moves, including center orientation, helps in designing efficient solving algorithms.\nCounting the 43 Quintillion Permutations To compute the number of possible Rubik’s Cube states, we analyze the degrees of freedom:\nThere are 8 corner pieces, each of which can be arranged in (8!) ways. Each corner has three orientations, giving (3^7) possibilities (the last one is determined by the others). There are 12 edge pieces, which can be arranged in (12!) ways. Each edge has two orientations, giving (2^{11}) possibilities (the last one is determined by the others). However, only even permutations of corners and edges are possible, so we divide by 2. Thus, the total number of possible Rubik’s Cube states is:\n$$ \\frac{8! \\times 3^7 \\times 12! \\times 2^{11}}{2} = 43,252,003,274,489,856,000 $$\nwhich is approximately 43 quintillion.\nFor the 2×2×2 Rubik’s Cube, we use a similar method but without considering edges:\nThe 8 corner pieces can be arranged in (8!) ways. Each has 3 orientations, giving (3^7) (since the last one is determined). Only even permutations are possible, so we divide by 2. Thus, the number of possible 2×2×2 states is:\n$$ \\frac{8! \\times 3^7}{2} = 3,674,160 $$\nwhich is significantly smaller than the 3×3×3 but still quite large.\nGod’s Number and Move Metrics God’s Number is the maximum number of moves required to solve the worst-case scenario of a Rubik’s Cube optimally. In 2010, researchers proved that God’s Number for a standard 3×3×3 Rubik’s Cube is 20 moves in the quarter-turn metric (where each 90-degree face turn counts as one move).\nMove Metrics Quarter-Turn Metric (QTM): Every 90-degree turn is counted as one move. This is the standard used in the 20-move God’s Number proof. Half-Turn Metric (HTM): Both 90-degree and 180-degree turns count as one move. In this metric, God’s Number is 18 moves. Face-Turn Metric (FTM): Any rotation of a face, whether 90, 180, or 270 degrees, is counted as one move. Different solving methods optimize for different metrics. For example, speedcubers prioritize fewer moves in practice rather than the theoretical minimum number of moves.\nEuclidean and Quaternion Mathematics in the Rubik’s Cube Euclidean Geometry and the Rubik’s Cube The Rubik’s Cube exists in three-dimensional Euclidean space, meaning its transformations can be represented using classical geometric tools such as matrices and vector operations.\nRotation Matrices: Each face rotation can be described using a 3×3 rotation matrix. A 90-degree clockwise rotation about the x, y, or z-axis can be represented as:\n$$ R_x(90^\\circ) = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; -1 \\ 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix}, $$\n$$ R_y(90^\\circ) = \\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; 1 \\ 0 \u0026amp; 1 \u0026amp; 0 \\ -1 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix}, $$\n$$ R_z(90^\\circ) = \\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0 \\ 1 \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}. $$\nVector Representation: Each cubie (small cube piece) has a position vector ( v ), and applying a rotation matrix transforms it to a new position: $$ v\u0026rsquo; = R v. $$ Using these transformations, all possible moves on the cube can be described mathematically.\nQuaternion Representation and the Rubik’s Cube Quaternions offer an alternative way to describe rotations in 3D space. A quaternion is defined as: $$ q = a + bi + cj + dk, $$ where ( a, b, c, d ) are real numbers, and ( i, j, k ) are imaginary unit vectors satisfying specific multiplication rules.\nRotation Using Quaternions: Any 3D rotation can be represented as: $$ q = \\cos\\left(\\frac{\\theta}{2}\\right) + \\sin\\left(\\frac{\\theta}{2}\\right)(xi + yj + zk), $$ where ( \\theta ) is the rotation angle, and ( (x, y, z) ) is the rotation axis.\nApplying a Rotation: Given a point represented by a quaternion ( p ), the rotated point ( p\u0026rsquo; ) is obtained as: $$ p\u0026rsquo; = q p q^{-1}. $$\nUsing quaternions avoids issues like gimbal lock and allows smooth, efficient calculations, making them useful in robotic cube solvers and computer simulations.\nComparison of Euclidean and Quaternion Methods Method Advantages Use Case in Rubik’s Cube Rotation Matrices Simple, easy to compute Manual cube manipulation, algebraic solving Quaternions No gimbal lock, computationally efficient Robotics, computer simulations While human solvers primarily use group-theoretic approaches, understanding Euclidean and quaternion mathematics is valuable for computational methods and AI-driven solutions.\nAdvanced Mathematics Behind the Rubik’s Cube Graph Theory and the Rubik’s Cube The entire state space of the Rubik’s Cube can be visualized as a graph, where:\nEach node represents a unique cube configuration. Each edge represents a valid move between two configurations. This allows us to analyze cube solving as a shortest path problem (like in Dijkstra’s algorithm). The challenge is that this graph is huge, containing about 43 quintillion nodes! Researchers have used Breadth-First Search (BFS) to explore how quickly the cube can be solved from any state, leading to the proof of God’s Number (20 in QTM).\nMarkov Chains and Random Scrambles If you randomly twist a Rubik’s Cube, how many moves does it take before it is \u0026ldquo;fully scrambled\u0026rdquo;? This is a classic Markov Chain problem, where each move represents a random transition between states. Studies suggest that after about 19-20 random moves, the cube is statistically close to a uniformly random state. This insight is used in competitive cubing to ensure fairness in official scramble generation.\nGroup Structure: Conjugacy Classes and Commutators The Rubik’s Cube group has special elements called commutators and conjugates, which are fundamental to advanced solving techniques:\nCommutator: ([A, B] = A B A^{-1} B^{-1}) – used in many algorithms to isolate cube pieces. Conjugate: (X A X^{-1}) – applies a transformation in a different context. These concepts allow cube solvers to move a small set of pieces without disrupting the rest, forming the basis for algorithms like CFOP, Roux, and ZZ methods.\nWhy Is Solving the Cube Hard? Computational Complexity Solving an arbitrary cube position optimally (in the least moves) is an NP-hard problem. That means there is no known efficient algorithm that can solve every case optimally in polynomial time. This is why human solvers use heuristic-based approaches like CFOP, Petrus, and Roux, rather than brute force computation.\nWhat’s Next? Computers and Efficient Cube Solving In our next post, we will explore how computers approach solving the Rubik’s Cube, including AI techniques, heuristics, and optimal solvers like Kociemba’s Algorithm and DeepCubeA.\n","date":"February 14, 2025","image":"/images/post/mathrub/image_hu_ce7a0b0179f317aa.png","permalink":"/blog/mathematics-behind-rubiks-cube/","title":"The Mathematics Behind the Rubik's Cube #PID1.3"},{"blog":["PID","RubiksCubeSolver","PID1","s","all"],"contents":"\rThe Rubik’s Cube, with its intricate design and colorful chaos, can seem overwhelming at first glance. However, solving it is not just about memorizing algorithms but about understanding the mechanics behind each move. There are several well-known solving methods, each with its own advantages and techniques that cater to different solving styles. Whether you\u0026rsquo;re aiming for speed, efficiency, or ergonomic moves, the CFOP, Roux, and ZZ methods offer distinct paths to mastery. These are all speed-solving methods designed for competitive cubing, but there are also beginner-friendly and alternative approaches like the Layer-by-Layer (LBL) and Petrus methods.\nCFOP: The Classic Speedcubing Approach CFOP (Cross – First Two Layers – Orientation of Last Layer – Permutation of Last Layer), also known as the Fridrich Method, is the most widely used method among speedcubers. It breaks the solve into four logical steps, enabling high efficiency and minimal pause between sequences.\nThe Cross The first step is solving a cross on one face of the cube, typically white. The aim is to position the four edge pieces correctly while minimizing moves. Advanced solvers focus on efficiency, ensuring that each edge is inserted optimally without unnecessary cube rotations. Many speedcubers practice solving the cross in eight moves or fewer to optimize their solving time.\nFirst Two Layers (F2L) Rather than solving corners and edges separately, F2L pairs them up before inserting them into their respective slots. This is a crucial speed improvement over beginner methods, reducing move count significantly. F2L can be learned intuitively, but advanced cubers memorize key cases and algorithms for increased efficiency.\nOrientation of the Last Layer (OLL) Once the first two layers are completed, the next step is orienting all pieces on the top layer so that the face becomes a uniform color. There are 57 possible cases, but beginners can use a two-step OLL approach with just ten algorithms.\nPermutation of the Last Layer (PLL) The final step is to permute the last layer pieces into their correct positions. This step requires knowledge of 21 algorithms in the full PLL method or just six in the two-look PLL approach. Mastering PLL allows for faster transition times and optimized finger tricks to reduce execution delays.\nCFOP is the go-to method for many speedcubers because of its structured approach and ability to handle high turn-per-second (TPS) solves with ease. Even I use CFOP for solving the cube now—I do an intuitive cross and F2L, then use 2-look OLL and 1-look PLL.\nFor 2x2, I use the CLL (Corners Last Layer) method. You can check out my times here: Cubelelo Profile (it\u0026rsquo;s unofficial, but yeah!).\nRoux: The Efficient Block-Building Method Roux, developed by Gilles Roux in 2003, takes a vastly different approach from CFOP. It focuses on reducing move count and minimizing cube rotations, making it ideal for one-handed solving. Unlike CFOP, Roux relies heavily on intuitive solving techniques and block-building rather than strict algorithm memorization.\nFirst Block The solve begins by constructing a 1x2x3 block on one side of the cube. This is done by strategically placing the edge and corner pieces in the correct positions without disrupting already solved parts.\nSecond Block A second 1x2x3 block is then built on the opposite side of the cube. At this point, the left and right blocks are complete, leaving only the middle slice and top layer unsolved.\nCMLL (Corner Orientation \u0026amp; Permutation) Instead of solving the last layer in steps like OLL and PLL, Roux addresses all four corners at once using CMLL (Corners of the Last Layer). This step requires only 42 algorithms but can be broken into smaller subsets for easier learning.\nLSE (Last Six Edges) The final stage focuses on solving the remaining six edges using M and U moves exclusively. This step is what makes Roux unique, as it avoids rotations and allows for smooth, fast execution.\nThe strength of Roux lies in its efficiency—solves often require fewer moves than CFOP, and its reliance on intuitive solving makes it an excellent alternative for those who prefer a different approach.\nZZ: The Method Designed for Ergonomics The ZZ method, named after its creator Zbigniew Zborowski, aims to balance efficiency and turning ergonomics. It pre-orients edges early in the solve, allowing the rest of the cube to be solved with only R, U, and L moves, eliminating cube rotations and awkward finger placements.\nEOLine (Edge Orientation \u0026amp; Line) The solve begins by orienting all edges while placing two key edges along the bottom. This setup ensures that later steps can be executed smoothly without disrupting edge orientation.\nFirst Two Layers (F2L) Unlike CFOP, which requires cube rotations for F2L, the ZZ method allows for rotationless F2L execution. Because edge orientation was handled in EOLine, all remaining F2L pairs can be inserted using only R, U, and L moves.\nLast Layer Since all edges are already oriented, solving the last layer can be approached using CFOP-style algorithms or ZZ-specific techniques. The most advanced ZZ solvers use ZBLL (Zborowski-Bruchem Last Layer), which solves the entire last layer in one step, requiring knowledge of over 400 algorithms.\nZZ is an excellent choice for solvers who want to improve ergonomics while maintaining low move counts. However, EOLine can be challenging to master, making it slightly more difficult for beginners compared to CFOP.\nLayer-by-Layer (LBL): The Beginner-Friendly Method The Layer-by-Layer (LBL) method is the most common beginner method. It involves solving the cube in three distinct layers:\nSolve the first layer by completing a cross and inserting corners. Solve the second layer by inserting edge pieces into their correct slots. Solve the last layer using algorithms to orient and permute the pieces. This method is easy to learn and provides a solid foundation for more advanced techniques like CFOP.\nPetrus Method: The Block-Building Alternative The Petrus Method, developed by Lars Petrus, is a block-building approach that reduces move count and improves efficiency:\nSolve a 2x2x2 block anywhere on the cube. Expand it to a 2x2x3 block. Orient the edges early to make solving easier. Solve the remaining pieces with minimal moves. This method is useful for those who want an alternative to CFOP and prefer a more flexible solving approach.\nChoosing the Right Method Each method has its strengths, and the best one depends on your goals:\nCFOP is the best choice for speedcubers aiming for high TPS and efficiency. Roux is ideal for solvers who prefer intuitive solving and minimal rotations. ZZ is suited for those who want ergonomic solves with fewer rotations. LBL is great for beginners starting with the cube. Petrus is perfect for those who enjoy a block-building approach. No matter which method you choose, improving your lookahead, finger tricks, and efficiency will always be key to becoming a faster solver. Try out different approaches and see what works best for you!\nHappy cubing!\n","date":"February 7, 2025","image":"/images/post/solverubcub/poster_hu_30c228d081c88326.png","permalink":"/blog/solving-the-rubiks-cube/","title":"Solving The Rubiks Cube #PID1.2"},{"blog":["PID","RubiksCubeSolver","PID1","s","all"],"contents":"The Rubik’s Cube is a 3D combination puzzle that has fascinated minds for decades. Invented in 1974 by Ernő Rubik, a Hungarian architect and professor, it was originally called the \u0026ldquo;Magic Cube.\u0026rdquo; Designed as a teaching tool to explain 3D movement, it quickly became a global sensation. The challenge? Scramble it, then restore each face to a single color—sounds simple, but millions have struggled (and succeeded) at it since!\nIf you are curious, you\u0026rsquo;ll find the puzzles around you. If you are determined, you will solve them -Erno Rubik\nHow a Rubik’s Cube is Structured At first glance, the Rubik’s Cube appears to be just 27 smaller cubes arranged in a 3x3 grid, but its internal mechanics are far more sophisticated. The core mechanism allows for smooth rotations, holding everything together while letting the outer pieces move freely.\nThe cube consists of three main types of pieces:\nCore: The core holds the entire structure intact. It consists of six fixed center pieces that never move relative to each other. Edges: The cube has 12 edge pieces, each with two colors, positioned between the centers. Corners: There are 8 corner pieces, each with three colors, which determine the cube’s orientation. Each of these pieces interlocks in a way that allows rotation without disassembling the puzzle. When twisted, the cube rearranges itself by moving these smaller components around the core, yet the entire structure remains stable.\nHow It Rotates and Functions Despite its scrambled look, a Rubik’s Cube follows a well-structured mechanical system:\nEach face rotates independently, thanks to the internal core mechanism. The center pieces remain static, acting as reference points for solving. Edge and corner pieces move around freely, rearranging their positions to create new patterns with every turn. Each move you make affects multiple pieces at once, creating complex shifts that can be solved using known algorithms. The key is to understand how these pieces interact with each turn to work towards a solution.\nRubik’s Cube Notation (3x3 Standard Moves) To communicate Rubik’s Cube solutions, we use standard notation:\nFace Turns:\nR (Right) – Rotate the right face 90° clockwise R\u0026rsquo; (Right Prime) – Rotate the right face 90° counterclockwise L (Left) – Rotate the left face 90° clockwise L\u0026rsquo; (Left Prime) – Rotate the left face 90° counterclockwise U (Up) – Rotate the top face 90° clockwise U\u0026rsquo; (Up Prime) – Rotate the top face 90° counterclockwise D (Down) – Rotate the bottom face 90° clockwise D\u0026rsquo; (Down Prime) – Rotate the bottom face 90° counterclockwise F (Front) – Rotate the front face 90° clockwise F\u0026rsquo; (Front Prime) – Rotate the front face 90° counterclockwise B (Back) – Rotate the back face 90° clockwise B\u0026rsquo; (Back Prime) – Rotate the back face 90° counterclockwise Double Turns:\nMoves followed by 2 (e.g., R2, U2) indicate a 180° turn in either direction. This notation is used universally among cubers, making it easier to follow solving guides and algorithms.\nColor Schemes and Face Orientation Most official Rubik’s Cubes follow a standardized color arrangement, which helps speedcubers recognize patterns quickly. The opposite face pairs are usually:\nWhite ↔ Yellow Blue ↔ Green Red ↔ Orange This scheme remains consistent across most cubes, ensuring uniformity in solving strategies. Recognizing the relationship between opposite faces is crucial when learning solving techniques, as many algorithms rely on the cube’s color orientation.\nDifferent Types of Rubik’s Cubes and Modifications The classic 3x3 is just the beginning! There are countless variations, each adding its own twist to the challenge:\nNxN Cubes (Larger and Smaller Variants) 2x2 (Mini Cube) – A simpler version, great for beginners. 3x3 (Standard Cube) – The original and most popular. 4x4 (Rubik’s Revenge) – Extra layers mean extra complexity. 5x5 (Professor’s Cube) – More layers, more challenge. Even larger cubes like 6x6, 7x7, and beyond exist for advanced solvers. Shape Modifications Fisher Cube – A 3x3 shape mod that appears to shift its center axis, making it visually deceptive. Windmill Cube – Features diagonal cuts, making rotations feel unpredictable. Axis Cube – Turns into a bizarre, asymmetric mess when scrambled. Mirror Cube – Solved by shape instead of color, adding an extra challenge. Other Unique Cubes Pyraminx – A triangular-based twisty puzzle with simpler movement mechanics. Megaminx – A 12-sided dodecahedron cube with an extra layer of complexity. Ghost Cube – A shape-shifting cube that must be solved by aligning irregularly shaped pieces rather than colors. Each of these variations presents a unique solving challenge, keeping cubers engaged for years!\nFinal Thoughts The Rubik’s Cube is more than just a toy—it’s a mechanical marvel, a brain workout, and an endless source of fun. Whether you’re solving a classic 3x3 or diving into the wild world of modded cubes, the principles remain the same: patterns, patience, and persistence. Solving a Rubik’s Cube can enhance cognitive skills like problem-solving, pattern recognition, and spatial awareness, making it a fantastic hobby for all ages.\nSo, grab a cube, start twisting, and embrace the puzzle madness! 🔄✨\n","date":"January 31, 2025","image":"/images/post/rubcubemech/poster_hu_45bf8a85a1324705.png","permalink":"/blog/mechanics-of-rubiks-cube/","title":"Mechanics of Rubiks Cube #PID1.1"},{"blog":["PID","RubiksCubeSolver","PID1","s","all"],"contents":"\rPuzzles. Whether it’s a crossword, Sudoku, or that infuriating jigsaw piece that just won’t fit, puzzles have a unique way of grabbing our attention and holding it hostage. But have you ever wondered why solving puzzles feels so satisfying? Beyond the fun, puzzles sharpen your mind, boost your problem-solving skills, and, let’s be honest, give you bragging rights.\nAt their core, puzzles are challenges—a structured way to ask, “How do I figure this out?” And that question is more important than you might think. Life, in many ways, is a giant puzzle: decisions, strategies, unexpected twists. The better we get at solving little puzzles, the more equipped we are for the big ones.\nWhy Solve Puzzles? Solving puzzles is like a gym session for your brain. They improve cognitive functions, boost memory, and enhance focus. But beyond brainpower, puzzles teach patience, perseverance, and the art of thinking outside the box—skills that are valuable in any field, from coding to cooking to simply navigating life.\nAnd let’s not forget the dopamine rush! Every solved puzzle is a small victory, and our brains love rewarding us for it. Who doesn’t like a mental high five?\nCoding: The Ultimate Mental Puzzle Now, let’s talk about coding—arguably one of the most satisfying puzzles you can tackle. Writing code is essentially solving a problem using logic, creativity, and a touch of wizardry. Each bug is a mini-puzzle, each feature a challenge to implement. And with coding puzzles, you’re not just solving; you’re building.\nFor those who’ve wrestled with algorithms, debugging, or optimizing code, you’ll agree: coding is a puzzle that never gets old. The beauty lies in its versatility. Problems evolve, solutions change, and the learning never stops.\nTwo Hands, One Brain: The Magic of Physical Puzzles Now, let’s take this a step further: puzzles that involve not just your mind but your hands too. Think about the Rubik’s Cube, where both hemispheres of your brain are engaged. The left brain loves the logical sequences and patterns, while the right brain enjoys the spatial awareness and creativity. It’s like a full-brain workout.\nPhysical puzzles improve hand-eye coordination, dexterity, and your ability to multitask. Plus, there’s something incredibly satisfying about manipulating an object and watching it transform under your hands. For me, working with physical puzzles has always been a humbling experience—you can’t brute force them; they demand focus and finesse.\nThe Rubik’s Cube: A Personal Journey Ah, the Rubik’s Cube—a classic that’s equal parts intriguing and intimidating. My first encounter with it was… chaotic, to say the least. Scrambling it was easy, but solving it? Let’s just say it took me more than a few attempts (and some YouTube tutorials) to get it right.\nBut once I did, it was magical. Solving a Rubik’s Cube is a dance of logic and intuition. It teaches you to think in layers, anticipate moves, and stay calm under pressure. And honestly, it’s just plain cool to whip one out and solve it in front of friends.\nPuzzles Meet Tech: The Rubik’s Cube Solver Now imagine combining the worlds of physical and digital puzzles. That’s exactly what we’ll be doing in the Rubik’s Cube Solver series. This project is a blend of hardware and software challenges—a perfect playground for anyone who loves puzzles.\nThe idea is to build a system that can solve a Rubik’s Cube autonomously. From understanding the cube’s mechanics to writing algorithms that optimize solutions, this project is as rewarding as it is complex. And here’s the best part: you’ll get to learn and build alongside me.\nNote: This project is still in its simulation phase. There are optimizations to be made, and the hardware implementation is yet to be completed. But that’s the beauty of this series—we’ll question every step, learn from every mistake, and inch closer to the solution together.\nIntroducing the PID Series The Rubik’s Cube Solver is just the beginning. The PID: Project IN Detail series is a deep dive into my projects, where I share insights, challenges, and breakthroughs. There’s a lot more to come, and I’m thrilled to have you along for the ride.\nIn the next few posts, we’ll start with the basics of solving a Rubik’s Cube—the foundational techniques that will help you tackle the puzzle manually. From there, we’ll explore how computers can do it better, faster, and with optimizations we can only dream of.\nWhy Wait? Let’s Get Started! Puzzles are more than a pastime; they’re a way of thinking, learning, and growing. Whether you’re a coding enthusiast, a Rubik’s Cube aficionado, or just someone who loves a good challenge, this series has something for you.\nSo grab a cube, roll up your sleeves, and let’s dive into the fascinating world of puzzles—one twist at a time.\n","date":"January 24, 2025","image":"/images/post/puzzles/puzzles_hu_9db1976df1f09a89.jpg","permalink":"/blog/why-should-you-start-solving-puzzles/","title":"Why Should You Start Solving Puzzles? #PID1.0"},{"blog":["personal","experience","s","all"],"contents":"Last year, I missed ROSCon India due to exams and, honestly, had no idea what I was missing out on. This year, though, I made it, and it turned out to be more than I ever imagined. The two days I spent at ROSConIN'24 were nothing short of transformative, and this blog itself is a result of the inspiration I drew from the event.\nSetting the Stage The second edition of ROSCon India, following the overwhelming success of last year’s event with 750+ attendees, was hosted by ARTPARK at the Indian Institute of Science (IISc), Bangalore. This event brought together developers, hobbyists, researchers, and industry professionals to share, learn, and network over all things ROS (Robot Operating System).\nWhat makes ROSCon India special is its resemblance to the international ROSCon, with a local flavor that emphasizes India’s growing influence in robotics and automation. It was heartwarming to see support from Open Robotics and the enthusiastic efforts of Acceleration Robotics, RigBetel Labs, and ARTPARK in organizing such an impactful gathering.\nDay 0: Workshops Galore The event kicked off with Workshop Day on December 4th. We could choose one out of three workshops, and I opted for the third one:\nWorkshop 1: Next-Gen Robotics Development with NVIDIA ISAAC, GenAI, and ROS – Organized by NVIDIA, this workshop offered a comprehensive dive into cutting-edge robotics development. Though I couldn’t attend it, the buzz from the attendees made it clear how enriching it was.\nWorkshop 2: Leveraging Zenoh as a ROS 2 Middleware Layer – Conducted by Zettascale Technology, this session explored Zenoh as an innovative middleware layer for ROS 2. It intrigued many participants and opened up discussions on its potential.\nWorkshop 3: ROS 2 Controls, Navigation, and Advanced Communication Study – Organized by ARTPARK, this was my pick! A deep dive into ROS 2 controls, navigation, and communication felt perfectly aligned with my interests. The hands-on experience and insights I gained were invaluable.\nDay 1: A Conference to Remember December 5th began with registrations and a warm welcome address by the organizers, setting an enthusiastic tone. Some highlights from the day included:\nKeynotes: Geoffrey Biggs (CTO, Open Robotics) and Yadunund Vijay (Intrinsic) discussed the state of Open Robotics in 2024, followed by Jigar Halani from NVIDIA sharing insights on robotics development. Inspiring Talks: From Yuvraj Mehta’s session on RoboGPT to Sarvesh Kumar Malladi’s insights on Universal Robots’ ROS2 features, each talk added depth to the learning experience. Industry Focus: Anish Dalvi from TCS delved into automotive protocols, while Somdeb Saha highlighted retail automation with ROS. Both sessions demonstrated the vast industrial applications of ROS. Panel Discussion: The day ended with an engaging panel on cracking the product-market fit in robotics, featuring founders and investors sharing valuable insights. Day 2: Deep Dives and Future Directions December 6th brought more enlightening sessions, including:\nKeynote by Angelo Corsaro (ZettaScale Technology): An in-depth look at Zenoh as an alternative middleware layer for ROS 2. Technical Sessions: From Ajay Sethi and Prateek Nagras introducing the Robotics Application Stack to Nidhi Choudhary’s integration of physics-based neural networks with Gazebo, the variety of topics covered was astounding. Fireside Chat: The event concluded with a thought-provoking discussion on the future of ROS, featuring Geoffrey Biggs, Yadunund Vijay, and Angelo Corsaro. Networking and Personal Highlights One of the most fulfilling aspects of ROSConIN’24 was the chance to meet incredible people. I connected with alumni from my college, including Aryan Jaguste and Jatin Vera, whose experience in robotics left me inspired. I also met many other professionals who have been in this field for years, generously sharing their knowledge and encouraging me to keep learning and experimenting.\nIt was this vibrant exchange of ideas and stories that inspired me to start this blog. ROSConIN’24 wasn’t just a conference; it was a catalyst for my growth in the robotics domain.\nA Big Shoutout A massive thanks to all the companies and individuals who made this event possible, including Acceleration Robotics, RigBetel Labs, ARTPARK, NVIDIA, Zettascale Technology, Tata Consultancy Services, Universal Robots, and many others like Autodiscovery, Botsoverkill, Bullwork, Golain, I-Hub Jodhpur, IISc, Kikobot, Nawe, Neuralzome, Thundroids, Vicharak, Virya, and xTerra.\nClosing Thoughts As I reflect on my experience, I can’t help but marvel at how much this event has broadened my horizons. It’s not just about the technical knowledge but also the sense of community and the shared passion for innovation. If you’re even remotely interested in robotics or automation, attending ROSConIN should be a no-brainer. Who knows? You might walk away with a new project idea, a mentor, or even the inspiration to start a blog, just like I did!\nAs if ROSConIN’24 wasn’t enough to fill my plate with excitement, the very next day, I found myself at the GNOME Asia Summit in Bangalore. It was an incredible opportunity to connect with open-source contributors and Linux enthusiasts. The vibe there was equally inspiring, and I came away with even more appreciation for the open-source community.\nSpeaking of Bangalore, let’s not forget the city\u0026rsquo;s legendary traffic. I’ll admit, navigating those jam-packed streets tested my patience (and Google Maps’ sanity), but the morning chill and the sheer energy of being in India’s tech hub more than made up for it. If you’ve never tried squeezing in two major conferences in one trip, let me tell you—it’s like a crash course in networking and caffeine dependency.\nMeeting passionate individuals at both events has only fueled my curiosity to dive deeper into robotics and open source. In fact, it was during ROSConIN’24 that I felt inspired to start this tech blog, channeling my excitement and insights into something more tangible. And hey, if I can navigate Bangalore traffic and two back-to-back conferences, I’m pretty sure I can handle just about anything life throws my way!\nInterestingly, I was one of the few people there who received an ID with a handwritten name instead of a printed one. A few people were even unsure if it was genuine—which honestly just added to the uniqueness of the experience.\n","date":"January 17, 2025","image":"/images/post/roscon/roscon_hu_89ad13263eb8ad10.jpg","permalink":"/blog/my-rosconin24-experience/","title":"My RosConIN'24 (+GNOME Asia Summit) Experience"},{"blog":["tips","s","all"],"contents":"\rIn 2025, with the internet brimming with TikToks, reels, and AI-generated articles, you might wonder—is blogging still worth it?\nThe answer is a resounding YES, and here’s why.\nWhy Blog in 2025? Share Your Unique Perspective In a world of AI-generated content, your personal voice matters more than ever. AI might generate the basics, but stories, experiences, and personal insights are uniquely human. Whether you’re building your first robot, sharing parenting tips, or learning a new language, your journey can inspire others.\nThink about it: How many times have you Googled a problem, stumbled upon a blog, and found exactly what you needed? That could be you helping someone else.\nBuild Your Digital Legacy Your blog is your corner of the internet—a space to leave your mark. Unlike fleeting social media posts, blogs are evergreen, searchable, and build a record of your growth. For developers, it can be a portfolio of your work; for creatives, it’s a gallery of your creations.\nI started my blog to document my tech projects, but I realized it’s also helping me keep track of my ideas, progress, and experiments. Plus, I’ve already met people who share the same passions—thanks to this little space!\nLearn as You Share Writing is an incredible teacher. To explain something clearly, you need to truly understand it yourself.\nDevelopers often blog about solutions to bugs or coding techniques, which not only helps others but reinforces their own knowledge. For non-tech folks, writing about personal projects—whether it’s DIY, cooking, or fitness—gives clarity and keeps you motivated. Pro Tip: Blogging can make you a better problem-solver. Breaking down problems into digestible steps is the essence of both writing and coding.\nBuild Connections and Opportunities Blogging isn’t just about putting your thoughts into words; it’s about starting conversations. Your blog can:\nAttract collaborators who resonate with your ideas. Impress potential employers or clients by showcasing your expertise. Connect you with a like-minded community. Think of it as networking without the awkward handshakes.\nStay Relevant in the AI Era AI is great for automating tasks, but creativity, originality, and storytelling? That’s all you. A blog lets you flex those creative muscles and prove you’re not just keeping up with the times—you’re shaping them.\nWhy Students Should Start Blogging 🎓 As a student, blogging can be a game-changer for your personal and professional growth. Here’s why:\nShowcase Your Skills:\nYour blog can act as a dynamic portfolio. Whether it’s coding projects, research papers, or even creative writing, it’s a platform to demonstrate your expertise and passion. Employers and professors love seeing initiative.\nDocument Your Learning:\nWriting about what you’re learning—whether it’s a tough algorithm, a robotics project, or study hacks—helps reinforce your understanding and creates a resource for others.\nStand Out:\nIn a competitive world, a well-maintained blog sets you apart. It shows that you’re not just a passive learner but someone who actively contributes to the community.\nBuild Connections:\nBlogging opens doors to collaborations, internships, and mentorships. Sharing your work publicly can attract like-minded peers, professors, or even recruiters.\nPro Tip for Students: Start small. Write about a project or concept you recently worked on in class—it’s a great way to begin!\nHow to Start Blogging in 2025 If all this has convinced you, let’s talk about how to get started! Whether you’re a dev documenting code or someone sharing life hacks, blogging has never been easier.\nChoose Your Purpose Ask yourself: Why do I want to blog?\nIs it to document your journey (like me)? Share your expertise? Build a personal brand? Just for fun? Defining your purpose will help you stay motivated and give your blog a clear focus.\nPick the Right Platform Here are a few options to suit different needs:\nTechies: Use GitHub Pages for free hosting or platforms like Jekyll/Hugo for custom setups. Beginners: Try WordPress or Ghost—they’re user-friendly and have tons of templates. Minimalists: Substack or Medium are great for simple, distraction-free writing. What I Use: I opted for GitHub Pages because I love having full control over my blog’s look and feel.\nWrite What You Know (And Love) Find your niche. You don’t need to be an expert—just share your journey as you learn.\nDevs: Write about side projects, tutorials, or debugging solutions. Non-devs: Document hobbies, productivity hacks, or personal experiences. Remember: What’s obvious to you might be groundbreaking to someone else.\nKeep It Simple (At First) Don’t overcomplicate it. Your first post can be:\nAn introduction to who you are. A story about a project you worked on. A simple “lesson learned” post. It’s okay if your first post isn’t perfect—it’s better to start and improve as you go.\nLeverage AI to Help You In 2025, AI tools can make blogging easier:\nUse ChatGPT for brainstorming post ideas. Grammarly can polish your grammar. Tools like Jasper AI can even generate draft content. But remember: your voice is the star. AI can assist, but authenticity is irreplaceable.\nPromote Your Blog Once your blog is live, share it!\nPost about it on LinkedIn, Instagram, or Twitter. Join communities (Reddit, Discord, forums) related to your niche. Collaborate with others by guest-posting or linking to their work. If you’re consistent, people will notice.\nEmbrace the Process Blogging is a journey. Don’t stress about being perfect—just keep writing, experimenting, and learning. Tools like Google Analytics can show you what’s working and help you refine your style.\nFinal Thoughts Blogging in 2025 is about more than just writing—it’s about sharing your voice, building connections, and leaving a legacy. Whether you’re a coder, a hobbyist, or someone with a passion to share, there’s never been a better time to start.\nYour Blog, Your Rules: It doesn’t have to be fancy. It just has to be you.\nWhat’s Next? If you’re thinking of starting a blog, go for it! Your ideas are worth sharing. Feel free to reach out if you need help setting things up or brainstorming ideas—I’d love to hear from you.\nReady to take the plunge? Hit that \u0026ldquo;New Blog\u0026rdquo; button and let the world hear your voice!\n","date":"January 10, 2025","image":"/images/post/blog/why-blog_hu_4c28246d5160cbaa.jpg","permalink":"/blog/why-blog-in-2025/","title":"Why Blog in 2025? (And How to Get Started)"},{"blog":["personal","s","all"],"contents":"\rHello, and thank you for visiting. My name is Jagadeesh, and this blog is a personal and professional record of my journey through college, projects, and the experiences that continue to shape my interests and aspirations.\nCurrently, I am pursuing my undergraduate studies at NIT Calicut, where I am learning, building, and continuously exploring new ideas across engineering, technology, and beyond.\nThis space reflects not only my technical pursuits but also my broader experiences—from milestones and challenges to reflections on the people and places that have influenced my path.\nI know no one would care to read this, even I sound like someone who thinks they do\u0026hellip; :( but anyways.\nThrough this blog, I aim to document my work thoughtfully, share insights, and connect with others who are equally passionate about learning and creating.\nPurpose of This Blog The main purpose of this blog is to organize and document my projects, ideas, and experiences in a structured way.\nOver time, I realized that many of my projects ended up scattered across private repositories or forgotten folders. This space is simply an effort to gather them in one place, with a bit more context and thoughtfulness. While most of the projects here are small or experimental, documenting them helps me reflect and learn. If anyone else happens to find something useful along the way, that would just be a nice bonus.\nThe content here includes technical notes, project write-ups, tutorials, and personal reflections from different experiences.\nAbout Me I am Jagadeesh Mummana, a sophomore at NIT Calicut, majoring in Electronics and Communication Engineering with a minor in Robotics and Automation.\nMy focus is on electronics and hardware design, particularly in VLSI systems, and how these can be used to optimize hardware for AI applications. I’m interested in improving hardware performance to support the intensive computational needs of AI models. I also enjoy the hands-on process of building real-world robots from scratch, where integrating hardware and software effectively is essential to their operation.\nI enjoy taking the time to understand systems; building them, exploring how they work, and trying to make small improvements through trial and error.\nOutside of academics, I spend time on personal projects, club activities, and technical experiments, as well as trying to slowly build both technical and creative skills.\nAbout This Site This site originally began as a portfolio project for my final submission in the CS50x 2024 Course.\nThe initial version remains accessible here or through the navigation bar.\nSince then, it has grown into a broader personal and technical blog.\nThe site is built with Hugo, using the Geeky-Hugo theme as a foundation, which I have extensively customized to better meet my evolving requirements. It is hosted via GitHub Pages.\nThe inspiration to start a formal blog came during my visit to ROSCon India 2024 (IISc Banglore).\nAt the event, I had the opportunity to interact with peers and seniors from several institutions, many of whom were doing exceptional work across different technical domains. I was struck by their clarity when explaining their projects, yet I noticed that structured documentation and public presentation of their work were often lacking.\nThrough conversations, it became apparent that this was not due to a lack of ability but rather due to documentation being a lower priority amidst academic and project commitments. This realization stayed with me and motivated me to establish a platform where I could not only share the technical details but also convey the motivations, processes, challenges, and insights behind each project.\nIt is my belief that even a basic project, when fully understood and properly documented, holds more educational and developmental value than a great one with only a surface-level understanding.\nTaking the time to work through each part of a project helps me learn more and feel more connected to the work.\nYou can find more about this inspiration and my reflections on the event in this post.\nWhy I Built This Blog This site serves as a central platform to organize, document, and share my technical work and experiments.\nSince many of my GitHub repositories are private, this blog acts as an open and structured window into the projects I am pursuing, providing detailed insights, learnings, and future directions.\nSome of the projects are actively maintained, others are works in progress, and a few have reached functional milestones but are continually refined as my understanding evolves.\nAll projects featured here are either independently developed or draw upon external inspirations, in which case appropriate credits are acknowledged.\nFor Industry Professionals/Recruiters If you are an industry professional or recruiter visiting this site, I encourage you to explore the \u0026ldquo;Projects\u0026rdquo; and \u0026ldquo;About\u0026rdquo; sections for a clearer perspective on my work, interests, and approach.\nI am currently seeking internship opportunities in areas such as digital and mixed-signal VLSI design, particularly those that intersect with robotics and AI-enhanced systems.\nI am always eager to learn and explore new challenges, and I would love the opportunity to contribute to innovative projects in these areas. If you\u0026rsquo;d like to explore any of my private repositories or discuss a project in more detail, I\u0026rsquo;d be happy to share them upon request.\nThank you for considering my work.\nFor Peers, Friends, and Fellow Explorers If you are a peer, a friend, or simply an interested visitor, I warmly welcome discussions, collaborations, and exchange of ideas.\nI believe that collaboration enriches learning for all parties involved, providing diverse perspectives and new ways of thinking.\nIf you have an idea to discuss, a project to collaborate on, or simply wish to connect, please feel free to reach out through the Contact Page or via direct messages on the platforms listed below.\nWhile I am active across multiple channels, my activity on Instagram is currently limited.\nWhy I Focus on Projects For those wondering why there is an emphasis on building and documenting projects, the reason is simple: I believe true learning comes through hands-on experience.\nAcademic projects often serve their purpose within fixed timelines, but rarely do they encourage continuous exploration beyond submission. When I initiate and manage a project entirely—starting from its original motivation through to real-world deployment—I develop a deeper sense of ownership and a stronger commitment to refine and improve it over time.\nMany of my projects span across disciplines, and this intersectional nature drives me to think critically and holistically. I am always open to collaborations that allow for exploration across varied fields.\nIn my view, engaging actively with projects provides a form of learning that cannot be replaced by passive consumption, whether through videos or multiple online courses.\nWhile these resources are important, I believe that their true value is realized when they are used as stepping stones to build something original and substantial.\nConnect With Me 🌐 Portfolio: mummanajagadeesh.github.io 💼 LinkedIn: Jagadeesh Mummana 🔧 GitHub: Mummanajagadeesh 📸 Instagram: @jagadeesh__97__ For additional social links and informal contact options, please visit the Contact Page.\nThank you for your time and interest. I look forward to continuing this journey of learning, building, and sharing, and I hope you find something here that resonates with you.\n","date":"January 3, 2025","image":"/images/post/hw/image_hu_86757ac4c9b1d4e1.png","permalink":"/blog/hello-world/","title":"Hello World!! (A MUST READ)"}]